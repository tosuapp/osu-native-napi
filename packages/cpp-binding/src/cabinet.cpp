// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include <cabinet.h>
#include <node_api.h>
#include <assert.h>
#include <stdio.h>
#include <cstdlib>
#include <vector>
#include "NAPIHelpers.h"

static napi_value register_enum__ErrorCode(napi_env env, napi_value exports)
{
    napi_status status;
    napi_value result;
    NAPI_CALL(env, napi_create_object(env, &result));

    // BUFFER_SIZE_QUERY
    napi_value i_0;
    status = napi_create_int32(env, -1, &i_0);
    assert(status == napi_ok);

    // SUCCESS
    napi_value i_1;
    status = napi_create_int32(env, 0, &i_1);
    assert(status == napi_ok);

    // OBJECT_NOT_RESOLVED
    napi_value i_2;
    status = napi_create_int32(env, 1, &i_2);
    assert(status == napi_ok);

    // RULESET_UNAVAILABLE
    napi_value i_3;
    status = napi_create_int32(env, 2, &i_3);
    assert(status == napi_ok);

    // UNEXPECTED_RULESET
    napi_value i_4;
    status = napi_create_int32(env, 3, &i_4);
    assert(status == napi_ok);

    // FAILURE
    napi_value i_5;
    status = napi_create_int32(env, 127, &i_5);
    assert(status == napi_ok);

    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "BUFFER_SIZE_QUERY", nullptr, nullptr, nullptr, nullptr, i_0, attributes, nullptr },
        { "SUCCESS", nullptr, nullptr, nullptr, nullptr, i_1, attributes, nullptr },
        { "OBJECT_NOT_RESOLVED", nullptr, nullptr, nullptr, nullptr, i_2, attributes, nullptr },
        { "RULESET_UNAVAILABLE", nullptr, nullptr, nullptr, nullptr, i_3, attributes, nullptr },
        { "UNEXPECTED_RULESET", nullptr, nullptr, nullptr, nullptr, i_4, attributes, nullptr },
        { "FAILURE", nullptr, nullptr, nullptr, nullptr, i_5, attributes, nullptr }
    };

    NAPI_CALL(env, napi_define_properties(env, result, sizeof(props) / sizeof(props[0]), props));

    return result;
}

static void dtor_ManagedObjectHandle_ManagedObjectHandle(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_ManagedObjectHandle_ManagedObjectHandle;

// ManagedObjectHandle::ManagedObjectHandle
static napi_value callback_method_ManagedObjectHandle_ManagedObjectHandle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    ManagedObjectHandle* instance = nullptr;

    instance = new ManagedObjectHandle();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_ManagedObjectHandle_ManagedObjectHandle, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// ManagedObjectHandle::__id
static napi_value getter_field_ManagedObjectHandle_id(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    ManagedObjectHandle* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____id;
    status = napi_create_int32(env, instance->id, &____id);
    assert(status == napi_ok);
    return ____id;
}

static napi_value setter_field_ManagedObjectHandle_id
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    ManagedObjectHandle* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __id;
    status = napi_get_value_int32(env, args[0], &__id);
    instance->id = (::int32_t)__id;
    return nullptr;
}

static napi_value register_class__ManagedObjectHandle(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "id", nullptr, nullptr, getter_field_ManagedObjectHandle_id, setter_field_ManagedObjectHandle_id, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "ManagedObjectHandle", NAPI_AUTO_LENGTH, callback_method_ManagedObjectHandle_ManagedObjectHandle, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_ManagedObjectHandle_ManagedObjectHandle);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeBeatmap_NativeBeatmap(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeBeatmap_NativeBeatmap;

// NativeBeatmap::NativeBeatmap
static napi_value callback_method_NativeBeatmap_NativeBeatmap(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeBeatmap* instance = nullptr;

    instance = new NativeBeatmap();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeBeatmap_NativeBeatmap, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeBeatmap::__handle
static napi_value getter_field_NativeBeatmap_handle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____handle_ctor;
    status = napi_get_reference_value(env, ctor_ManagedObjectHandle_ManagedObjectHandle, &____handle_ctor);
    assert(status == napi_ok);

    napi_value ____handle_instance;
    status = napi_new_instance(env, ____handle_ctor, 0, nullptr, &____handle_instance);
    assert(status == napi_ok);

    ManagedObjectHandle* ____handle_native;
    status = napi_unwrap(env, ____handle_instance, (void**) &____handle_native);
    assert(status == napi_ok);
    *____handle_native = *&instance->handle;

    return ____handle_instance;
}

static napi_value setter_field_NativeBeatmap_handle
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    ManagedObjectHandle* __handle_instance;
    status = napi_unwrap(env, args[0], (void**) &__handle_instance);
    instance->handle = *__handle_instance;
    return nullptr;
}

// NativeBeatmap::__rulesetId
static napi_value getter_field_NativeBeatmap_rulesetId(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____rulesetId;
    status = napi_create_int32(env, instance->rulesetId, &____rulesetId);
    assert(status == napi_ok);
    return ____rulesetId;
}

static napi_value setter_field_NativeBeatmap_rulesetId
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __rulesetId;
    status = napi_get_value_int32(env, args[0], &__rulesetId);
    instance->rulesetId = (::int32_t)__rulesetId;
    return nullptr;
}

// NativeBeatmap::__beatmapId
static napi_value getter_field_NativeBeatmap_beatmapId(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____beatmapId;
    status = napi_create_int32(env, instance->beatmapId, &____beatmapId);
    assert(status == napi_ok);
    return ____beatmapId;
}

static napi_value setter_field_NativeBeatmap_beatmapId
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __beatmapId;
    status = napi_get_value_int32(env, args[0], &__beatmapId);
    instance->beatmapId = (::int32_t)__beatmapId;
    return nullptr;
}

// NativeBeatmap::__approachRate
static napi_value getter_field_NativeBeatmap_approachRate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____approachRate;
    status = napi_create_double(env, instance->approachRate, &____approachRate);
    assert(status == napi_ok);
    return ____approachRate;
}

static napi_value setter_field_NativeBeatmap_approachRate
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __approachRate;
    status = napi_get_value_double(env, args[0], &__approachRate);
    instance->approachRate = (float)__approachRate;
    return nullptr;
}

// NativeBeatmap::__drainRate
static napi_value getter_field_NativeBeatmap_drainRate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____drainRate;
    status = napi_create_double(env, instance->drainRate, &____drainRate);
    assert(status == napi_ok);
    return ____drainRate;
}

static napi_value setter_field_NativeBeatmap_drainRate
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __drainRate;
    status = napi_get_value_double(env, args[0], &__drainRate);
    instance->drainRate = (float)__drainRate;
    return nullptr;
}

// NativeBeatmap::__overallDifficulty
static napi_value getter_field_NativeBeatmap_overallDifficulty(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____overallDifficulty;
    status = napi_create_double(env, instance->overallDifficulty, &____overallDifficulty);
    assert(status == napi_ok);
    return ____overallDifficulty;
}

static napi_value setter_field_NativeBeatmap_overallDifficulty
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __overallDifficulty;
    status = napi_get_value_double(env, args[0], &__overallDifficulty);
    instance->overallDifficulty = (float)__overallDifficulty;
    return nullptr;
}

// NativeBeatmap::__circleSize
static napi_value getter_field_NativeBeatmap_circleSize(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____circleSize;
    status = napi_create_double(env, instance->circleSize, &____circleSize);
    assert(status == napi_ok);
    return ____circleSize;
}

static napi_value setter_field_NativeBeatmap_circleSize
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __circleSize;
    status = napi_get_value_double(env, args[0], &__circleSize);
    instance->circleSize = (float)__circleSize;
    return nullptr;
}

// NativeBeatmap::__sliderMultiplier
static napi_value getter_field_NativeBeatmap_sliderMultiplier(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____sliderMultiplier;
    status = napi_create_double(env, instance->sliderMultiplier, &____sliderMultiplier);
    assert(status == napi_ok);
    return ____sliderMultiplier;
}

static napi_value setter_field_NativeBeatmap_sliderMultiplier
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __sliderMultiplier;
    status = napi_get_value_double(env, args[0], &__sliderMultiplier);
    instance->sliderMultiplier = __sliderMultiplier;
    return nullptr;
}

// NativeBeatmap::__sliderTickRate
static napi_value getter_field_NativeBeatmap_sliderTickRate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____sliderTickRate;
    status = napi_create_double(env, instance->sliderTickRate, &____sliderTickRate);
    assert(status == napi_ok);
    return ____sliderTickRate;
}

static napi_value setter_field_NativeBeatmap_sliderTickRate
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeBeatmap* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __sliderTickRate;
    status = napi_get_value_double(env, args[0], &__sliderTickRate);
    instance->sliderTickRate = __sliderTickRate;
    return nullptr;
}

static napi_value register_class__NativeBeatmap(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "handle", nullptr, nullptr, getter_field_NativeBeatmap_handle, setter_field_NativeBeatmap_handle, nullptr, attributes, nullptr },
        { "rulesetId", nullptr, nullptr, getter_field_NativeBeatmap_rulesetId, setter_field_NativeBeatmap_rulesetId, nullptr, attributes, nullptr },
        { "beatmapId", nullptr, nullptr, getter_field_NativeBeatmap_beatmapId, setter_field_NativeBeatmap_beatmapId, nullptr, attributes, nullptr },
        { "approachRate", nullptr, nullptr, getter_field_NativeBeatmap_approachRate, setter_field_NativeBeatmap_approachRate, nullptr, attributes, nullptr },
        { "drainRate", nullptr, nullptr, getter_field_NativeBeatmap_drainRate, setter_field_NativeBeatmap_drainRate, nullptr, attributes, nullptr },
        { "overallDifficulty", nullptr, nullptr, getter_field_NativeBeatmap_overallDifficulty, setter_field_NativeBeatmap_overallDifficulty, nullptr, attributes, nullptr },
        { "circleSize", nullptr, nullptr, getter_field_NativeBeatmap_circleSize, setter_field_NativeBeatmap_circleSize, nullptr, attributes, nullptr },
        { "sliderMultiplier", nullptr, nullptr, getter_field_NativeBeatmap_sliderMultiplier, setter_field_NativeBeatmap_sliderMultiplier, nullptr, attributes, nullptr },
        { "sliderTickRate", nullptr, nullptr, getter_field_NativeBeatmap_sliderTickRate, setter_field_NativeBeatmap_sliderTickRate, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeBeatmap", NAPI_AUTO_LENGTH, callback_method_NativeBeatmap_NativeBeatmap, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeBeatmap_NativeBeatmap);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeMod_NativeMod(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeMod_NativeMod;

// NativeMod::NativeMod
static napi_value callback_method_NativeMod_NativeMod(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeMod* instance = nullptr;

    instance = new NativeMod();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeMod_NativeMod, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeMod::__handle
static napi_value getter_field_NativeMod_handle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeMod* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____handle_ctor;
    status = napi_get_reference_value(env, ctor_ManagedObjectHandle_ManagedObjectHandle, &____handle_ctor);
    assert(status == napi_ok);

    napi_value ____handle_instance;
    status = napi_new_instance(env, ____handle_ctor, 0, nullptr, &____handle_instance);
    assert(status == napi_ok);

    ManagedObjectHandle* ____handle_native;
    status = napi_unwrap(env, ____handle_instance, (void**) &____handle_native);
    assert(status == napi_ok);
    *____handle_native = *&instance->handle;

    return ____handle_instance;
}

static napi_value setter_field_NativeMod_handle
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeMod* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    ManagedObjectHandle* __handle_instance;
    status = napi_unwrap(env, args[0], (void**) &__handle_instance);
    instance->handle = *__handle_instance;
    return nullptr;
}

static napi_value register_class__NativeMod(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "handle", nullptr, nullptr, getter_field_NativeMod_handle, setter_field_NativeMod_handle, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeMod", NAPI_AUTO_LENGTH, callback_method_NativeMod_NativeMod, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeMod_NativeMod);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeModsCollection_NativeModsCollection(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeModsCollection_NativeModsCollection;

// NativeModsCollection::NativeModsCollection
static napi_value callback_method_NativeModsCollection_NativeModsCollection(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeModsCollection* instance = nullptr;

    instance = new NativeModsCollection();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeModsCollection_NativeModsCollection, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeModsCollection::__handle
static napi_value getter_field_NativeModsCollection_handle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeModsCollection* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____handle_ctor;
    status = napi_get_reference_value(env, ctor_ManagedObjectHandle_ManagedObjectHandle, &____handle_ctor);
    assert(status == napi_ok);

    napi_value ____handle_instance;
    status = napi_new_instance(env, ____handle_ctor, 0, nullptr, &____handle_instance);
    assert(status == napi_ok);

    ManagedObjectHandle* ____handle_native;
    status = napi_unwrap(env, ____handle_instance, (void**) &____handle_native);
    assert(status == napi_ok);
    *____handle_native = *&instance->handle;

    return ____handle_instance;
}

static napi_value setter_field_NativeModsCollection_handle
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeModsCollection* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    ManagedObjectHandle* __handle_instance;
    status = napi_unwrap(env, args[0], (void**) &__handle_instance);
    instance->handle = *__handle_instance;
    return nullptr;
}

static napi_value register_class__NativeModsCollection(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "handle", nullptr, nullptr, getter_field_NativeModsCollection_handle, setter_field_NativeModsCollection_handle, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeModsCollection", NAPI_AUTO_LENGTH, callback_method_NativeModsCollection_NativeModsCollection, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeModsCollection_NativeModsCollection);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeRuleset_NativeRuleset(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeRuleset_NativeRuleset;

// NativeRuleset::NativeRuleset
static napi_value callback_method_NativeRuleset_NativeRuleset(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeRuleset* instance = nullptr;

    instance = new NativeRuleset();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeRuleset_NativeRuleset, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeRuleset::__handle
static napi_value getter_field_NativeRuleset_handle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeRuleset* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____handle_ctor;
    status = napi_get_reference_value(env, ctor_ManagedObjectHandle_ManagedObjectHandle, &____handle_ctor);
    assert(status == napi_ok);

    napi_value ____handle_instance;
    status = napi_new_instance(env, ____handle_ctor, 0, nullptr, &____handle_instance);
    assert(status == napi_ok);

    ManagedObjectHandle* ____handle_native;
    status = napi_unwrap(env, ____handle_instance, (void**) &____handle_native);
    assert(status == napi_ok);
    *____handle_native = *&instance->handle;

    return ____handle_instance;
}

static napi_value setter_field_NativeRuleset_handle
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeRuleset* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    ManagedObjectHandle* __handle_instance;
    status = napi_unwrap(env, args[0], (void**) &__handle_instance);
    instance->handle = *__handle_instance;
    return nullptr;
}

// NativeRuleset::__rulesetId
static napi_value getter_field_NativeRuleset_rulesetId(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeRuleset* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____rulesetId;
    status = napi_create_int32(env, instance->rulesetId, &____rulesetId);
    assert(status == napi_ok);
    return ____rulesetId;
}

static napi_value setter_field_NativeRuleset_rulesetId
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeRuleset* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __rulesetId;
    status = napi_get_value_int32(env, args[0], &__rulesetId);
    instance->rulesetId = (::int32_t)__rulesetId;
    return nullptr;
}

static napi_value register_class__NativeRuleset(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "handle", nullptr, nullptr, getter_field_NativeRuleset_handle, setter_field_NativeRuleset_handle, nullptr, attributes, nullptr },
        { "rulesetId", nullptr, nullptr, getter_field_NativeRuleset_rulesetId, setter_field_NativeRuleset_rulesetId, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeRuleset", NAPI_AUTO_LENGTH, callback_method_NativeRuleset_NativeRuleset, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeRuleset_NativeRuleset);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeScoreInfo_NativeScoreInfo(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeScoreInfo_NativeScoreInfo;

// NativeScoreInfo::NativeScoreInfo
static napi_value callback_method_NativeScoreInfo_NativeScoreInfo(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeScoreInfo* instance = nullptr;

    instance = new NativeScoreInfo();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeScoreInfo_NativeScoreInfo, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeScoreInfo::__rulesetHandle
static napi_value getter_field_NativeScoreInfo_rulesetHandle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____rulesetHandle_ctor;
    status = napi_get_reference_value(env, ctor_ManagedObjectHandle_ManagedObjectHandle, &____rulesetHandle_ctor);
    assert(status == napi_ok);

    napi_value ____rulesetHandle_instance;
    status = napi_new_instance(env, ____rulesetHandle_ctor, 0, nullptr, &____rulesetHandle_instance);
    assert(status == napi_ok);

    ManagedObjectHandle* ____rulesetHandle_native;
    status = napi_unwrap(env, ____rulesetHandle_instance, (void**) &____rulesetHandle_native);
    assert(status == napi_ok);
    *____rulesetHandle_native = *&instance->rulesetHandle;

    return ____rulesetHandle_instance;
}

static napi_value setter_field_NativeScoreInfo_rulesetHandle
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    ManagedObjectHandle* __rulesetHandle_instance;
    status = napi_unwrap(env, args[0], (void**) &__rulesetHandle_instance);
    instance->rulesetHandle = *__rulesetHandle_instance;
    return nullptr;
}

// NativeScoreInfo::__beatmapHandle
static napi_value getter_field_NativeScoreInfo_beatmapHandle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____beatmapHandle_ctor;
    status = napi_get_reference_value(env, ctor_ManagedObjectHandle_ManagedObjectHandle, &____beatmapHandle_ctor);
    assert(status == napi_ok);

    napi_value ____beatmapHandle_instance;
    status = napi_new_instance(env, ____beatmapHandle_ctor, 0, nullptr, &____beatmapHandle_instance);
    assert(status == napi_ok);

    ManagedObjectHandle* ____beatmapHandle_native;
    status = napi_unwrap(env, ____beatmapHandle_instance, (void**) &____beatmapHandle_native);
    assert(status == napi_ok);
    *____beatmapHandle_native = *&instance->beatmapHandle;

    return ____beatmapHandle_instance;
}

static napi_value setter_field_NativeScoreInfo_beatmapHandle
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    ManagedObjectHandle* __beatmapHandle_instance;
    status = napi_unwrap(env, args[0], (void**) &__beatmapHandle_instance);
    instance->beatmapHandle = *__beatmapHandle_instance;
    return nullptr;
}

// NativeScoreInfo::__modsHandle
static napi_value getter_field_NativeScoreInfo_modsHandle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____modsHandle_ctor;
    status = napi_get_reference_value(env, ctor_ManagedObjectHandle_ManagedObjectHandle, &____modsHandle_ctor);
    assert(status == napi_ok);

    napi_value ____modsHandle_instance;
    status = napi_new_instance(env, ____modsHandle_ctor, 0, nullptr, &____modsHandle_instance);
    assert(status == napi_ok);

    ManagedObjectHandle* ____modsHandle_native;
    status = napi_unwrap(env, ____modsHandle_instance, (void**) &____modsHandle_native);
    assert(status == napi_ok);
    *____modsHandle_native = *&instance->modsHandle;

    return ____modsHandle_instance;
}

static napi_value setter_field_NativeScoreInfo_modsHandle
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    ManagedObjectHandle* __modsHandle_instance;
    status = napi_unwrap(env, args[0], (void**) &__modsHandle_instance);
    instance->modsHandle = *__modsHandle_instance;
    return nullptr;
}

// NativeScoreInfo::__maxCombo
static napi_value getter_field_NativeScoreInfo_maxCombo(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____maxCombo;
    status = napi_create_int32(env, instance->maxCombo, &____maxCombo);
    assert(status == napi_ok);
    return ____maxCombo;
}

static napi_value setter_field_NativeScoreInfo_maxCombo
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __maxCombo;
    status = napi_get_value_int32(env, args[0], &__maxCombo);
    instance->maxCombo = (::int32_t)__maxCombo;
    return nullptr;
}

// NativeScoreInfo::__accuracy
static napi_value getter_field_NativeScoreInfo_accuracy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____accuracy;
    status = napi_create_double(env, instance->accuracy, &____accuracy);
    assert(status == napi_ok);
    return ____accuracy;
}

static napi_value setter_field_NativeScoreInfo_accuracy
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __accuracy;
    status = napi_get_value_double(env, args[0], &__accuracy);
    instance->accuracy = __accuracy;
    return nullptr;
}

// NativeScoreInfo::__countMiss
static napi_value getter_field_NativeScoreInfo_countMiss(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____countMiss;
    status = napi_create_int32(env, instance->countMiss, &____countMiss);
    assert(status == napi_ok);
    return ____countMiss;
}

static napi_value setter_field_NativeScoreInfo_countMiss
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __countMiss;
    status = napi_get_value_int32(env, args[0], &__countMiss);
    instance->countMiss = (::int32_t)__countMiss;
    return nullptr;
}

// NativeScoreInfo::__countMeh
static napi_value getter_field_NativeScoreInfo_countMeh(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____countMeh;
    status = napi_create_int32(env, instance->countMeh, &____countMeh);
    assert(status == napi_ok);
    return ____countMeh;
}

static napi_value setter_field_NativeScoreInfo_countMeh
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __countMeh;
    status = napi_get_value_int32(env, args[0], &__countMeh);
    instance->countMeh = (::int32_t)__countMeh;
    return nullptr;
}

// NativeScoreInfo::__countOk
static napi_value getter_field_NativeScoreInfo_countOk(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____countOk;
    status = napi_create_int32(env, instance->countOk, &____countOk);
    assert(status == napi_ok);
    return ____countOk;
}

static napi_value setter_field_NativeScoreInfo_countOk
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __countOk;
    status = napi_get_value_int32(env, args[0], &__countOk);
    instance->countOk = (::int32_t)__countOk;
    return nullptr;
}

// NativeScoreInfo::__countGood
static napi_value getter_field_NativeScoreInfo_countGood(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____countGood;
    status = napi_create_int32(env, instance->countGood, &____countGood);
    assert(status == napi_ok);
    return ____countGood;
}

static napi_value setter_field_NativeScoreInfo_countGood
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __countGood;
    status = napi_get_value_int32(env, args[0], &__countGood);
    instance->countGood = (::int32_t)__countGood;
    return nullptr;
}

// NativeScoreInfo::__countGreat
static napi_value getter_field_NativeScoreInfo_countGreat(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____countGreat;
    status = napi_create_int32(env, instance->countGreat, &____countGreat);
    assert(status == napi_ok);
    return ____countGreat;
}

static napi_value setter_field_NativeScoreInfo_countGreat
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __countGreat;
    status = napi_get_value_int32(env, args[0], &__countGreat);
    instance->countGreat = (::int32_t)__countGreat;
    return nullptr;
}

// NativeScoreInfo::__countPerfect
static napi_value getter_field_NativeScoreInfo_countPerfect(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____countPerfect;
    status = napi_create_int32(env, instance->countPerfect, &____countPerfect);
    assert(status == napi_ok);
    return ____countPerfect;
}

static napi_value setter_field_NativeScoreInfo_countPerfect
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __countPerfect;
    status = napi_get_value_int32(env, args[0], &__countPerfect);
    instance->countPerfect = (::int32_t)__countPerfect;
    return nullptr;
}

// NativeScoreInfo::__countSliderTailHit
static napi_value getter_field_NativeScoreInfo_countSliderTailHit(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____countSliderTailHit;
    status = napi_create_int32(env, instance->countSliderTailHit, &____countSliderTailHit);
    assert(status == napi_ok);
    return ____countSliderTailHit;
}

static napi_value setter_field_NativeScoreInfo_countSliderTailHit
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __countSliderTailHit;
    status = napi_get_value_int32(env, args[0], &__countSliderTailHit);
    instance->countSliderTailHit = (::int32_t)__countSliderTailHit;
    return nullptr;
}

// NativeScoreInfo::__countLargeTickMiss
static napi_value getter_field_NativeScoreInfo_countLargeTickMiss(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____countLargeTickMiss;
    status = napi_create_int32(env, instance->countLargeTickMiss, &____countLargeTickMiss);
    assert(status == napi_ok);
    return ____countLargeTickMiss;
}

static napi_value setter_field_NativeScoreInfo_countLargeTickMiss
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeScoreInfo* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __countLargeTickMiss;
    status = napi_get_value_int32(env, args[0], &__countLargeTickMiss);
    instance->countLargeTickMiss = (::int32_t)__countLargeTickMiss;
    return nullptr;
}

static napi_value register_class__NativeScoreInfo(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "rulesetHandle", nullptr, nullptr, getter_field_NativeScoreInfo_rulesetHandle, setter_field_NativeScoreInfo_rulesetHandle, nullptr, attributes, nullptr },
        { "beatmapHandle", nullptr, nullptr, getter_field_NativeScoreInfo_beatmapHandle, setter_field_NativeScoreInfo_beatmapHandle, nullptr, attributes, nullptr },
        { "modsHandle", nullptr, nullptr, getter_field_NativeScoreInfo_modsHandle, setter_field_NativeScoreInfo_modsHandle, nullptr, attributes, nullptr },
        { "maxCombo", nullptr, nullptr, getter_field_NativeScoreInfo_maxCombo, setter_field_NativeScoreInfo_maxCombo, nullptr, attributes, nullptr },
        { "accuracy", nullptr, nullptr, getter_field_NativeScoreInfo_accuracy, setter_field_NativeScoreInfo_accuracy, nullptr, attributes, nullptr },
        { "countMiss", nullptr, nullptr, getter_field_NativeScoreInfo_countMiss, setter_field_NativeScoreInfo_countMiss, nullptr, attributes, nullptr },
        { "countMeh", nullptr, nullptr, getter_field_NativeScoreInfo_countMeh, setter_field_NativeScoreInfo_countMeh, nullptr, attributes, nullptr },
        { "countOk", nullptr, nullptr, getter_field_NativeScoreInfo_countOk, setter_field_NativeScoreInfo_countOk, nullptr, attributes, nullptr },
        { "countGood", nullptr, nullptr, getter_field_NativeScoreInfo_countGood, setter_field_NativeScoreInfo_countGood, nullptr, attributes, nullptr },
        { "countGreat", nullptr, nullptr, getter_field_NativeScoreInfo_countGreat, setter_field_NativeScoreInfo_countGreat, nullptr, attributes, nullptr },
        { "countPerfect", nullptr, nullptr, getter_field_NativeScoreInfo_countPerfect, setter_field_NativeScoreInfo_countPerfect, nullptr, attributes, nullptr },
        { "countSliderTailHit", nullptr, nullptr, getter_field_NativeScoreInfo_countSliderTailHit, setter_field_NativeScoreInfo_countSliderTailHit, nullptr, attributes, nullptr },
        { "countLargeTickMiss", nullptr, nullptr, getter_field_NativeScoreInfo_countLargeTickMiss, setter_field_NativeScoreInfo_countLargeTickMiss, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeScoreInfo", NAPI_AUTO_LENGTH, callback_method_NativeScoreInfo_NativeScoreInfo, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeScoreInfo_NativeScoreInfo);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeCatchPerformanceAttributes_NativeCatchPerformanceAttributes(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeCatchPerformanceAttributes_NativeCatchPerformanceAttributes;

// NativeCatchPerformanceAttributes::NativeCatchPerformanceAttributes
static napi_value callback_method_NativeCatchPerformanceAttributes_NativeCatchPerformanceAttributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeCatchPerformanceAttributes* instance = nullptr;

    instance = new NativeCatchPerformanceAttributes();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeCatchPerformanceAttributes_NativeCatchPerformanceAttributes, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeCatchPerformanceAttributes::__total
static napi_value getter_field_NativeCatchPerformanceAttributes_total(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeCatchPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____total;
    status = napi_create_double(env, instance->total, &____total);
    assert(status == napi_ok);
    return ____total;
}

static napi_value setter_field_NativeCatchPerformanceAttributes_total
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeCatchPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __total;
    status = napi_get_value_double(env, args[0], &__total);
    instance->total = __total;
    return nullptr;
}

static napi_value register_class__NativeCatchPerformanceAttributes(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "total", nullptr, nullptr, getter_field_NativeCatchPerformanceAttributes_total, setter_field_NativeCatchPerformanceAttributes_total, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeCatchPerformanceAttributes", NAPI_AUTO_LENGTH, callback_method_NativeCatchPerformanceAttributes_NativeCatchPerformanceAttributes, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeCatchPerformanceAttributes_NativeCatchPerformanceAttributes);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeCatchPerformanceCalculator_NativeCatchPerformanceCalculator(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeCatchPerformanceCalculator_NativeCatchPerformanceCalculator;

// NativeCatchPerformanceCalculator::NativeCatchPerformanceCalculator
static napi_value callback_method_NativeCatchPerformanceCalculator_NativeCatchPerformanceCalculator(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeCatchPerformanceCalculator* instance = nullptr;

    instance = new NativeCatchPerformanceCalculator();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeCatchPerformanceCalculator_NativeCatchPerformanceCalculator, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeCatchPerformanceCalculator::__handle
static napi_value getter_field_NativeCatchPerformanceCalculator_handle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeCatchPerformanceCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____handle_ctor;
    status = napi_get_reference_value(env, ctor_ManagedObjectHandle_ManagedObjectHandle, &____handle_ctor);
    assert(status == napi_ok);

    napi_value ____handle_instance;
    status = napi_new_instance(env, ____handle_ctor, 0, nullptr, &____handle_instance);
    assert(status == napi_ok);

    ManagedObjectHandle* ____handle_native;
    status = napi_unwrap(env, ____handle_instance, (void**) &____handle_native);
    assert(status == napi_ok);
    *____handle_native = *&instance->handle;

    return ____handle_instance;
}

static napi_value setter_field_NativeCatchPerformanceCalculator_handle
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeCatchPerformanceCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    ManagedObjectHandle* __handle_instance;
    status = napi_unwrap(env, args[0], (void**) &__handle_instance);
    instance->handle = *__handle_instance;
    return nullptr;
}

static napi_value register_class__NativeCatchPerformanceCalculator(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "handle", nullptr, nullptr, getter_field_NativeCatchPerformanceCalculator_handle, setter_field_NativeCatchPerformanceCalculator_handle, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeCatchPerformanceCalculator", NAPI_AUTO_LENGTH, callback_method_NativeCatchPerformanceCalculator_NativeCatchPerformanceCalculator, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeCatchPerformanceCalculator_NativeCatchPerformanceCalculator);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeManiaPerformanceAttributes_NativeManiaPerformanceAttributes(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeManiaPerformanceAttributes_NativeManiaPerformanceAttributes;

// NativeManiaPerformanceAttributes::NativeManiaPerformanceAttributes
static napi_value callback_method_NativeManiaPerformanceAttributes_NativeManiaPerformanceAttributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeManiaPerformanceAttributes* instance = nullptr;

    instance = new NativeManiaPerformanceAttributes();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeManiaPerformanceAttributes_NativeManiaPerformanceAttributes, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeManiaPerformanceAttributes::__total
static napi_value getter_field_NativeManiaPerformanceAttributes_total(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeManiaPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____total;
    status = napi_create_double(env, instance->total, &____total);
    assert(status == napi_ok);
    return ____total;
}

static napi_value setter_field_NativeManiaPerformanceAttributes_total
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeManiaPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __total;
    status = napi_get_value_double(env, args[0], &__total);
    instance->total = __total;
    return nullptr;
}

// NativeManiaPerformanceAttributes::__difficulty
static napi_value getter_field_NativeManiaPerformanceAttributes_difficulty(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeManiaPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____difficulty;
    status = napi_create_double(env, instance->difficulty, &____difficulty);
    assert(status == napi_ok);
    return ____difficulty;
}

static napi_value setter_field_NativeManiaPerformanceAttributes_difficulty
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeManiaPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __difficulty;
    status = napi_get_value_double(env, args[0], &__difficulty);
    instance->difficulty = __difficulty;
    return nullptr;
}

static napi_value register_class__NativeManiaPerformanceAttributes(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "total", nullptr, nullptr, getter_field_NativeManiaPerformanceAttributes_total, setter_field_NativeManiaPerformanceAttributes_total, nullptr, attributes, nullptr },
        { "difficulty", nullptr, nullptr, getter_field_NativeManiaPerformanceAttributes_difficulty, setter_field_NativeManiaPerformanceAttributes_difficulty, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeManiaPerformanceAttributes", NAPI_AUTO_LENGTH, callback_method_NativeManiaPerformanceAttributes_NativeManiaPerformanceAttributes, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeManiaPerformanceAttributes_NativeManiaPerformanceAttributes);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeManiaPerformanceCalculator_NativeManiaPerformanceCalculator(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeManiaPerformanceCalculator_NativeManiaPerformanceCalculator;

// NativeManiaPerformanceCalculator::NativeManiaPerformanceCalculator
static napi_value callback_method_NativeManiaPerformanceCalculator_NativeManiaPerformanceCalculator(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeManiaPerformanceCalculator* instance = nullptr;

    instance = new NativeManiaPerformanceCalculator();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeManiaPerformanceCalculator_NativeManiaPerformanceCalculator, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeManiaPerformanceCalculator::__handle
static napi_value getter_field_NativeManiaPerformanceCalculator_handle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeManiaPerformanceCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____handle_ctor;
    status = napi_get_reference_value(env, ctor_ManagedObjectHandle_ManagedObjectHandle, &____handle_ctor);
    assert(status == napi_ok);

    napi_value ____handle_instance;
    status = napi_new_instance(env, ____handle_ctor, 0, nullptr, &____handle_instance);
    assert(status == napi_ok);

    ManagedObjectHandle* ____handle_native;
    status = napi_unwrap(env, ____handle_instance, (void**) &____handle_native);
    assert(status == napi_ok);
    *____handle_native = *&instance->handle;

    return ____handle_instance;
}

static napi_value setter_field_NativeManiaPerformanceCalculator_handle
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeManiaPerformanceCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    ManagedObjectHandle* __handle_instance;
    status = napi_unwrap(env, args[0], (void**) &__handle_instance);
    instance->handle = *__handle_instance;
    return nullptr;
}

static napi_value register_class__NativeManiaPerformanceCalculator(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "handle", nullptr, nullptr, getter_field_NativeManiaPerformanceCalculator_handle, setter_field_NativeManiaPerformanceCalculator_handle, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeManiaPerformanceCalculator", NAPI_AUTO_LENGTH, callback_method_NativeManiaPerformanceCalculator_NativeManiaPerformanceCalculator, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeManiaPerformanceCalculator_NativeManiaPerformanceCalculator);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_Cabinet__Nullable_double_Cabinet__Nullable_double(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_Cabinet__Nullable_double_Cabinet__Nullable_double;

// Cabinet__Nullable_double::Cabinet__Nullable_double
static napi_value callback_method_Cabinet__Nullable_double_Cabinet__Nullable_double(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    Cabinet__Nullable_double* instance = nullptr;

    instance = new Cabinet__Nullable_double();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_Cabinet__Nullable_double_Cabinet__Nullable_double, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// Cabinet__Nullable_double::__hasValue
static napi_value getter_field_Cabinet__Nullable_double_hasValue(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    Cabinet__Nullable_double* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____hasValue;
    status = napi_get_boolean(env, instance->hasValue, &____hasValue);
    assert(status == napi_ok);
    return ____hasValue;
}

static napi_value setter_field_Cabinet__Nullable_double_hasValue
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    Cabinet__Nullable_double* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    bool __hasValue;
    status = napi_get_value_bool(env, args[0], &__hasValue);
    instance->hasValue = (bool)__hasValue;
    return nullptr;
}

// Cabinet__Nullable_double::__value
static napi_value getter_field_Cabinet__Nullable_double_value(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    Cabinet__Nullable_double* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____value;
    status = napi_create_double(env, instance->value, &____value);
    assert(status == napi_ok);
    return ____value;
}

static napi_value setter_field_Cabinet__Nullable_double_value
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    Cabinet__Nullable_double* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __value;
    status = napi_get_value_double(env, args[0], &__value);
    instance->value = __value;
    return nullptr;
}

static napi_value register_class__Cabinet__Nullable_double(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "hasValue", nullptr, nullptr, getter_field_Cabinet__Nullable_double_hasValue, setter_field_Cabinet__Nullable_double_hasValue, nullptr, attributes, nullptr },
        { "value", nullptr, nullptr, getter_field_Cabinet__Nullable_double_value, setter_field_Cabinet__Nullable_double_value, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "Cabinet__Nullable_double", NAPI_AUTO_LENGTH, callback_method_Cabinet__Nullable_double_Cabinet__Nullable_double, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_Cabinet__Nullable_double_Cabinet__Nullable_double);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeOsuPerformanceAttributes_NativeOsuPerformanceAttributes(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeOsuPerformanceAttributes_NativeOsuPerformanceAttributes;

// NativeOsuPerformanceAttributes::NativeOsuPerformanceAttributes
static napi_value callback_method_NativeOsuPerformanceAttributes_NativeOsuPerformanceAttributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeOsuPerformanceAttributes* instance = nullptr;

    instance = new NativeOsuPerformanceAttributes();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeOsuPerformanceAttributes_NativeOsuPerformanceAttributes, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeOsuPerformanceAttributes::__total
static napi_value getter_field_NativeOsuPerformanceAttributes_total(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____total;
    status = napi_create_double(env, instance->total, &____total);
    assert(status == napi_ok);
    return ____total;
}

static napi_value setter_field_NativeOsuPerformanceAttributes_total
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __total;
    status = napi_get_value_double(env, args[0], &__total);
    instance->total = __total;
    return nullptr;
}

// NativeOsuPerformanceAttributes::__aim
static napi_value getter_field_NativeOsuPerformanceAttributes_aim(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____aim;
    status = napi_create_double(env, instance->aim, &____aim);
    assert(status == napi_ok);
    return ____aim;
}

static napi_value setter_field_NativeOsuPerformanceAttributes_aim
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __aim;
    status = napi_get_value_double(env, args[0], &__aim);
    instance->aim = __aim;
    return nullptr;
}

// NativeOsuPerformanceAttributes::__speed
static napi_value getter_field_NativeOsuPerformanceAttributes_speed(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____speed;
    status = napi_create_double(env, instance->speed, &____speed);
    assert(status == napi_ok);
    return ____speed;
}

static napi_value setter_field_NativeOsuPerformanceAttributes_speed
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __speed;
    status = napi_get_value_double(env, args[0], &__speed);
    instance->speed = __speed;
    return nullptr;
}

// NativeOsuPerformanceAttributes::__accuracy
static napi_value getter_field_NativeOsuPerformanceAttributes_accuracy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____accuracy;
    status = napi_create_double(env, instance->accuracy, &____accuracy);
    assert(status == napi_ok);
    return ____accuracy;
}

static napi_value setter_field_NativeOsuPerformanceAttributes_accuracy
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __accuracy;
    status = napi_get_value_double(env, args[0], &__accuracy);
    instance->accuracy = __accuracy;
    return nullptr;
}

// NativeOsuPerformanceAttributes::__flashlight
static napi_value getter_field_NativeOsuPerformanceAttributes_flashlight(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____flashlight;
    status = napi_create_double(env, instance->flashlight, &____flashlight);
    assert(status == napi_ok);
    return ____flashlight;
}

static napi_value setter_field_NativeOsuPerformanceAttributes_flashlight
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __flashlight;
    status = napi_get_value_double(env, args[0], &__flashlight);
    instance->flashlight = __flashlight;
    return nullptr;
}

// NativeOsuPerformanceAttributes::__effectiveMissCount
static napi_value getter_field_NativeOsuPerformanceAttributes_effectiveMissCount(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____effectiveMissCount;
    status = napi_create_double(env, instance->effectiveMissCount, &____effectiveMissCount);
    assert(status == napi_ok);
    return ____effectiveMissCount;
}

static napi_value setter_field_NativeOsuPerformanceAttributes_effectiveMissCount
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __effectiveMissCount;
    status = napi_get_value_double(env, args[0], &__effectiveMissCount);
    instance->effectiveMissCount = __effectiveMissCount;
    return nullptr;
}

// NativeOsuPerformanceAttributes::__speedDeviation
static napi_value getter_field_NativeOsuPerformanceAttributes_speedDeviation(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____speedDeviation_ctor;
    status = napi_get_reference_value(env, ctor_Cabinet__Nullable_double_Cabinet__Nullable_double, &____speedDeviation_ctor);
    assert(status == napi_ok);

    napi_value ____speedDeviation_instance;
    status = napi_new_instance(env, ____speedDeviation_ctor, 0, nullptr, &____speedDeviation_instance);
    assert(status == napi_ok);

    Cabinet__Nullable_double* ____speedDeviation_native;
    status = napi_unwrap(env, ____speedDeviation_instance, (void**) &____speedDeviation_native);
    assert(status == napi_ok);
    *____speedDeviation_native = *&instance->speedDeviation;

    return ____speedDeviation_instance;
}

static napi_value setter_field_NativeOsuPerformanceAttributes_speedDeviation
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    Cabinet__Nullable_double* __speedDeviation_instance;
    status = napi_unwrap(env, args[0], (void**) &__speedDeviation_instance);
    instance->speedDeviation = *__speedDeviation_instance;
    return nullptr;
}

// NativeOsuPerformanceAttributes::__comboBasedEstimatedMissCount
static napi_value getter_field_NativeOsuPerformanceAttributes_comboBasedEstimatedMissCount(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____comboBasedEstimatedMissCount;
    status = napi_create_double(env, instance->comboBasedEstimatedMissCount, &____comboBasedEstimatedMissCount);
    assert(status == napi_ok);
    return ____comboBasedEstimatedMissCount;
}

static napi_value setter_field_NativeOsuPerformanceAttributes_comboBasedEstimatedMissCount
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __comboBasedEstimatedMissCount;
    status = napi_get_value_double(env, args[0], &__comboBasedEstimatedMissCount);
    instance->comboBasedEstimatedMissCount = __comboBasedEstimatedMissCount;
    return nullptr;
}

// NativeOsuPerformanceAttributes::__scoreBasedEstimatedMissCount
static napi_value getter_field_NativeOsuPerformanceAttributes_scoreBasedEstimatedMissCount(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____scoreBasedEstimatedMissCount_ctor;
    status = napi_get_reference_value(env, ctor_Cabinet__Nullable_double_Cabinet__Nullable_double, &____scoreBasedEstimatedMissCount_ctor);
    assert(status == napi_ok);

    napi_value ____scoreBasedEstimatedMissCount_instance;
    status = napi_new_instance(env, ____scoreBasedEstimatedMissCount_ctor, 0, nullptr, &____scoreBasedEstimatedMissCount_instance);
    assert(status == napi_ok);

    Cabinet__Nullable_double* ____scoreBasedEstimatedMissCount_native;
    status = napi_unwrap(env, ____scoreBasedEstimatedMissCount_instance, (void**) &____scoreBasedEstimatedMissCount_native);
    assert(status == napi_ok);
    *____scoreBasedEstimatedMissCount_native = *&instance->scoreBasedEstimatedMissCount;

    return ____scoreBasedEstimatedMissCount_instance;
}

static napi_value setter_field_NativeOsuPerformanceAttributes_scoreBasedEstimatedMissCount
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    Cabinet__Nullable_double* __scoreBasedEstimatedMissCount_instance;
    status = napi_unwrap(env, args[0], (void**) &__scoreBasedEstimatedMissCount_instance);
    instance->scoreBasedEstimatedMissCount = *__scoreBasedEstimatedMissCount_instance;
    return nullptr;
}

// NativeOsuPerformanceAttributes::__aimEstimatedSliderBreaks
static napi_value getter_field_NativeOsuPerformanceAttributes_aimEstimatedSliderBreaks(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____aimEstimatedSliderBreaks;
    status = napi_create_double(env, instance->aimEstimatedSliderBreaks, &____aimEstimatedSliderBreaks);
    assert(status == napi_ok);
    return ____aimEstimatedSliderBreaks;
}

static napi_value setter_field_NativeOsuPerformanceAttributes_aimEstimatedSliderBreaks
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __aimEstimatedSliderBreaks;
    status = napi_get_value_double(env, args[0], &__aimEstimatedSliderBreaks);
    instance->aimEstimatedSliderBreaks = __aimEstimatedSliderBreaks;
    return nullptr;
}

// NativeOsuPerformanceAttributes::__speedEstimatedSliderBreaks
static napi_value getter_field_NativeOsuPerformanceAttributes_speedEstimatedSliderBreaks(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____speedEstimatedSliderBreaks;
    status = napi_create_double(env, instance->speedEstimatedSliderBreaks, &____speedEstimatedSliderBreaks);
    assert(status == napi_ok);
    return ____speedEstimatedSliderBreaks;
}

static napi_value setter_field_NativeOsuPerformanceAttributes_speedEstimatedSliderBreaks
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __speedEstimatedSliderBreaks;
    status = napi_get_value_double(env, args[0], &__speedEstimatedSliderBreaks);
    instance->speedEstimatedSliderBreaks = __speedEstimatedSliderBreaks;
    return nullptr;
}

static napi_value register_class__NativeOsuPerformanceAttributes(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "total", nullptr, nullptr, getter_field_NativeOsuPerformanceAttributes_total, setter_field_NativeOsuPerformanceAttributes_total, nullptr, attributes, nullptr },
        { "aim", nullptr, nullptr, getter_field_NativeOsuPerformanceAttributes_aim, setter_field_NativeOsuPerformanceAttributes_aim, nullptr, attributes, nullptr },
        { "speed", nullptr, nullptr, getter_field_NativeOsuPerformanceAttributes_speed, setter_field_NativeOsuPerformanceAttributes_speed, nullptr, attributes, nullptr },
        { "accuracy", nullptr, nullptr, getter_field_NativeOsuPerformanceAttributes_accuracy, setter_field_NativeOsuPerformanceAttributes_accuracy, nullptr, attributes, nullptr },
        { "flashlight", nullptr, nullptr, getter_field_NativeOsuPerformanceAttributes_flashlight, setter_field_NativeOsuPerformanceAttributes_flashlight, nullptr, attributes, nullptr },
        { "effectiveMissCount", nullptr, nullptr, getter_field_NativeOsuPerformanceAttributes_effectiveMissCount, setter_field_NativeOsuPerformanceAttributes_effectiveMissCount, nullptr, attributes, nullptr },
        { "speedDeviation", nullptr, nullptr, getter_field_NativeOsuPerformanceAttributes_speedDeviation, setter_field_NativeOsuPerformanceAttributes_speedDeviation, nullptr, attributes, nullptr },
        { "comboBasedEstimatedMissCount", nullptr, nullptr, getter_field_NativeOsuPerformanceAttributes_comboBasedEstimatedMissCount, setter_field_NativeOsuPerformanceAttributes_comboBasedEstimatedMissCount, nullptr, attributes, nullptr },
        { "scoreBasedEstimatedMissCount", nullptr, nullptr, getter_field_NativeOsuPerformanceAttributes_scoreBasedEstimatedMissCount, setter_field_NativeOsuPerformanceAttributes_scoreBasedEstimatedMissCount, nullptr, attributes, nullptr },
        { "aimEstimatedSliderBreaks", nullptr, nullptr, getter_field_NativeOsuPerformanceAttributes_aimEstimatedSliderBreaks, setter_field_NativeOsuPerformanceAttributes_aimEstimatedSliderBreaks, nullptr, attributes, nullptr },
        { "speedEstimatedSliderBreaks", nullptr, nullptr, getter_field_NativeOsuPerformanceAttributes_speedEstimatedSliderBreaks, setter_field_NativeOsuPerformanceAttributes_speedEstimatedSliderBreaks, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeOsuPerformanceAttributes", NAPI_AUTO_LENGTH, callback_method_NativeOsuPerformanceAttributes_NativeOsuPerformanceAttributes, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeOsuPerformanceAttributes_NativeOsuPerformanceAttributes);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeOsuPerformanceCalculator_NativeOsuPerformanceCalculator(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeOsuPerformanceCalculator_NativeOsuPerformanceCalculator;

// NativeOsuPerformanceCalculator::NativeOsuPerformanceCalculator
static napi_value callback_method_NativeOsuPerformanceCalculator_NativeOsuPerformanceCalculator(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeOsuPerformanceCalculator* instance = nullptr;

    instance = new NativeOsuPerformanceCalculator();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeOsuPerformanceCalculator_NativeOsuPerformanceCalculator, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeOsuPerformanceCalculator::__handle
static napi_value getter_field_NativeOsuPerformanceCalculator_handle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____handle_ctor;
    status = napi_get_reference_value(env, ctor_ManagedObjectHandle_ManagedObjectHandle, &____handle_ctor);
    assert(status == napi_ok);

    napi_value ____handle_instance;
    status = napi_new_instance(env, ____handle_ctor, 0, nullptr, &____handle_instance);
    assert(status == napi_ok);

    ManagedObjectHandle* ____handle_native;
    status = napi_unwrap(env, ____handle_instance, (void**) &____handle_native);
    assert(status == napi_ok);
    *____handle_native = *&instance->handle;

    return ____handle_instance;
}

static napi_value setter_field_NativeOsuPerformanceCalculator_handle
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuPerformanceCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    ManagedObjectHandle* __handle_instance;
    status = napi_unwrap(env, args[0], (void**) &__handle_instance);
    instance->handle = *__handle_instance;
    return nullptr;
}

static napi_value register_class__NativeOsuPerformanceCalculator(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "handle", nullptr, nullptr, getter_field_NativeOsuPerformanceCalculator_handle, setter_field_NativeOsuPerformanceCalculator_handle, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeOsuPerformanceCalculator", NAPI_AUTO_LENGTH, callback_method_NativeOsuPerformanceCalculator_NativeOsuPerformanceCalculator, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeOsuPerformanceCalculator_NativeOsuPerformanceCalculator);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeTaikoPerformanceAttributes_NativeTaikoPerformanceAttributes(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeTaikoPerformanceAttributes_NativeTaikoPerformanceAttributes;

// NativeTaikoPerformanceAttributes::NativeTaikoPerformanceAttributes
static napi_value callback_method_NativeTaikoPerformanceAttributes_NativeTaikoPerformanceAttributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeTaikoPerformanceAttributes* instance = nullptr;

    instance = new NativeTaikoPerformanceAttributes();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeTaikoPerformanceAttributes_NativeTaikoPerformanceAttributes, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeTaikoPerformanceAttributes::__total
static napi_value getter_field_NativeTaikoPerformanceAttributes_total(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____total;
    status = napi_create_double(env, instance->total, &____total);
    assert(status == napi_ok);
    return ____total;
}

static napi_value setter_field_NativeTaikoPerformanceAttributes_total
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __total;
    status = napi_get_value_double(env, args[0], &__total);
    instance->total = __total;
    return nullptr;
}

// NativeTaikoPerformanceAttributes::__difficulty
static napi_value getter_field_NativeTaikoPerformanceAttributes_difficulty(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____difficulty;
    status = napi_create_double(env, instance->difficulty, &____difficulty);
    assert(status == napi_ok);
    return ____difficulty;
}

static napi_value setter_field_NativeTaikoPerformanceAttributes_difficulty
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __difficulty;
    status = napi_get_value_double(env, args[0], &__difficulty);
    instance->difficulty = __difficulty;
    return nullptr;
}

// NativeTaikoPerformanceAttributes::__accuracy
static napi_value getter_field_NativeTaikoPerformanceAttributes_accuracy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____accuracy;
    status = napi_create_double(env, instance->accuracy, &____accuracy);
    assert(status == napi_ok);
    return ____accuracy;
}

static napi_value setter_field_NativeTaikoPerformanceAttributes_accuracy
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __accuracy;
    status = napi_get_value_double(env, args[0], &__accuracy);
    instance->accuracy = __accuracy;
    return nullptr;
}

// NativeTaikoPerformanceAttributes::__estimatedUnstableRate
static napi_value getter_field_NativeTaikoPerformanceAttributes_estimatedUnstableRate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____estimatedUnstableRate_ctor;
    status = napi_get_reference_value(env, ctor_Cabinet__Nullable_double_Cabinet__Nullable_double, &____estimatedUnstableRate_ctor);
    assert(status == napi_ok);

    napi_value ____estimatedUnstableRate_instance;
    status = napi_new_instance(env, ____estimatedUnstableRate_ctor, 0, nullptr, &____estimatedUnstableRate_instance);
    assert(status == napi_ok);

    Cabinet__Nullable_double* ____estimatedUnstableRate_native;
    status = napi_unwrap(env, ____estimatedUnstableRate_instance, (void**) &____estimatedUnstableRate_native);
    assert(status == napi_ok);
    *____estimatedUnstableRate_native = *&instance->estimatedUnstableRate;

    return ____estimatedUnstableRate_instance;
}

static napi_value setter_field_NativeTaikoPerformanceAttributes_estimatedUnstableRate
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoPerformanceAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    Cabinet__Nullable_double* __estimatedUnstableRate_instance;
    status = napi_unwrap(env, args[0], (void**) &__estimatedUnstableRate_instance);
    instance->estimatedUnstableRate = *__estimatedUnstableRate_instance;
    return nullptr;
}

static napi_value register_class__NativeTaikoPerformanceAttributes(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "total", nullptr, nullptr, getter_field_NativeTaikoPerformanceAttributes_total, setter_field_NativeTaikoPerformanceAttributes_total, nullptr, attributes, nullptr },
        { "difficulty", nullptr, nullptr, getter_field_NativeTaikoPerformanceAttributes_difficulty, setter_field_NativeTaikoPerformanceAttributes_difficulty, nullptr, attributes, nullptr },
        { "accuracy", nullptr, nullptr, getter_field_NativeTaikoPerformanceAttributes_accuracy, setter_field_NativeTaikoPerformanceAttributes_accuracy, nullptr, attributes, nullptr },
        { "estimatedUnstableRate", nullptr, nullptr, getter_field_NativeTaikoPerformanceAttributes_estimatedUnstableRate, setter_field_NativeTaikoPerformanceAttributes_estimatedUnstableRate, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeTaikoPerformanceAttributes", NAPI_AUTO_LENGTH, callback_method_NativeTaikoPerformanceAttributes_NativeTaikoPerformanceAttributes, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeTaikoPerformanceAttributes_NativeTaikoPerformanceAttributes);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeTaikoPerformanceCalculator_NativeTaikoPerformanceCalculator(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeTaikoPerformanceCalculator_NativeTaikoPerformanceCalculator;

// NativeTaikoPerformanceCalculator::NativeTaikoPerformanceCalculator
static napi_value callback_method_NativeTaikoPerformanceCalculator_NativeTaikoPerformanceCalculator(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeTaikoPerformanceCalculator* instance = nullptr;

    instance = new NativeTaikoPerformanceCalculator();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeTaikoPerformanceCalculator_NativeTaikoPerformanceCalculator, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeTaikoPerformanceCalculator::__handle
static napi_value getter_field_NativeTaikoPerformanceCalculator_handle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoPerformanceCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____handle_ctor;
    status = napi_get_reference_value(env, ctor_ManagedObjectHandle_ManagedObjectHandle, &____handle_ctor);
    assert(status == napi_ok);

    napi_value ____handle_instance;
    status = napi_new_instance(env, ____handle_ctor, 0, nullptr, &____handle_instance);
    assert(status == napi_ok);

    ManagedObjectHandle* ____handle_native;
    status = napi_unwrap(env, ____handle_instance, (void**) &____handle_native);
    assert(status == napi_ok);
    *____handle_native = *&instance->handle;

    return ____handle_instance;
}

static napi_value setter_field_NativeTaikoPerformanceCalculator_handle
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoPerformanceCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    ManagedObjectHandle* __handle_instance;
    status = napi_unwrap(env, args[0], (void**) &__handle_instance);
    instance->handle = *__handle_instance;
    return nullptr;
}

static napi_value register_class__NativeTaikoPerformanceCalculator(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "handle", nullptr, nullptr, getter_field_NativeTaikoPerformanceCalculator_handle, setter_field_NativeTaikoPerformanceCalculator_handle, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeTaikoPerformanceCalculator", NAPI_AUTO_LENGTH, callback_method_NativeTaikoPerformanceCalculator_NativeTaikoPerformanceCalculator, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeTaikoPerformanceCalculator_NativeTaikoPerformanceCalculator);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeCatchDifficultyAttributes_NativeCatchDifficultyAttributes(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeCatchDifficultyAttributes_NativeCatchDifficultyAttributes;

// NativeCatchDifficultyAttributes::NativeCatchDifficultyAttributes
static napi_value callback_method_NativeCatchDifficultyAttributes_NativeCatchDifficultyAttributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeCatchDifficultyAttributes* instance = nullptr;

    instance = new NativeCatchDifficultyAttributes();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeCatchDifficultyAttributes_NativeCatchDifficultyAttributes, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeCatchDifficultyAttributes::__starRating
static napi_value getter_field_NativeCatchDifficultyAttributes_starRating(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeCatchDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____starRating;
    status = napi_create_double(env, instance->starRating, &____starRating);
    assert(status == napi_ok);
    return ____starRating;
}

static napi_value setter_field_NativeCatchDifficultyAttributes_starRating
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeCatchDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __starRating;
    status = napi_get_value_double(env, args[0], &__starRating);
    instance->starRating = __starRating;
    return nullptr;
}

// NativeCatchDifficultyAttributes::__maxCombo
static napi_value getter_field_NativeCatchDifficultyAttributes_maxCombo(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeCatchDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____maxCombo;
    status = napi_create_int32(env, instance->maxCombo, &____maxCombo);
    assert(status == napi_ok);
    return ____maxCombo;
}

static napi_value setter_field_NativeCatchDifficultyAttributes_maxCombo
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeCatchDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __maxCombo;
    status = napi_get_value_int32(env, args[0], &__maxCombo);
    instance->maxCombo = (::int32_t)__maxCombo;
    return nullptr;
}

static napi_value register_class__NativeCatchDifficultyAttributes(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "starRating", nullptr, nullptr, getter_field_NativeCatchDifficultyAttributes_starRating, setter_field_NativeCatchDifficultyAttributes_starRating, nullptr, attributes, nullptr },
        { "maxCombo", nullptr, nullptr, getter_field_NativeCatchDifficultyAttributes_maxCombo, setter_field_NativeCatchDifficultyAttributes_maxCombo, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeCatchDifficultyAttributes", NAPI_AUTO_LENGTH, callback_method_NativeCatchDifficultyAttributes_NativeCatchDifficultyAttributes, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeCatchDifficultyAttributes_NativeCatchDifficultyAttributes);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeCatchDifficultyCalculator_NativeCatchDifficultyCalculator(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeCatchDifficultyCalculator_NativeCatchDifficultyCalculator;

// NativeCatchDifficultyCalculator::NativeCatchDifficultyCalculator
static napi_value callback_method_NativeCatchDifficultyCalculator_NativeCatchDifficultyCalculator(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeCatchDifficultyCalculator* instance = nullptr;

    instance = new NativeCatchDifficultyCalculator();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeCatchDifficultyCalculator_NativeCatchDifficultyCalculator, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeCatchDifficultyCalculator::__handle
static napi_value getter_field_NativeCatchDifficultyCalculator_handle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeCatchDifficultyCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____handle_ctor;
    status = napi_get_reference_value(env, ctor_ManagedObjectHandle_ManagedObjectHandle, &____handle_ctor);
    assert(status == napi_ok);

    napi_value ____handle_instance;
    status = napi_new_instance(env, ____handle_ctor, 0, nullptr, &____handle_instance);
    assert(status == napi_ok);

    ManagedObjectHandle* ____handle_native;
    status = napi_unwrap(env, ____handle_instance, (void**) &____handle_native);
    assert(status == napi_ok);
    *____handle_native = *&instance->handle;

    return ____handle_instance;
}

static napi_value setter_field_NativeCatchDifficultyCalculator_handle
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeCatchDifficultyCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    ManagedObjectHandle* __handle_instance;
    status = napi_unwrap(env, args[0], (void**) &__handle_instance);
    instance->handle = *__handle_instance;
    return nullptr;
}

static napi_value register_class__NativeCatchDifficultyCalculator(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "handle", nullptr, nullptr, getter_field_NativeCatchDifficultyCalculator_handle, setter_field_NativeCatchDifficultyCalculator_handle, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeCatchDifficultyCalculator", NAPI_AUTO_LENGTH, callback_method_NativeCatchDifficultyCalculator_NativeCatchDifficultyCalculator, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeCatchDifficultyCalculator_NativeCatchDifficultyCalculator);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeManiaDifficultyAttributes_NativeManiaDifficultyAttributes(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeManiaDifficultyAttributes_NativeManiaDifficultyAttributes;

// NativeManiaDifficultyAttributes::NativeManiaDifficultyAttributes
static napi_value callback_method_NativeManiaDifficultyAttributes_NativeManiaDifficultyAttributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeManiaDifficultyAttributes* instance = nullptr;

    instance = new NativeManiaDifficultyAttributes();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeManiaDifficultyAttributes_NativeManiaDifficultyAttributes, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeManiaDifficultyAttributes::__starRating
static napi_value getter_field_NativeManiaDifficultyAttributes_starRating(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeManiaDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____starRating;
    status = napi_create_double(env, instance->starRating, &____starRating);
    assert(status == napi_ok);
    return ____starRating;
}

static napi_value setter_field_NativeManiaDifficultyAttributes_starRating
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeManiaDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __starRating;
    status = napi_get_value_double(env, args[0], &__starRating);
    instance->starRating = __starRating;
    return nullptr;
}

// NativeManiaDifficultyAttributes::__maxCombo
static napi_value getter_field_NativeManiaDifficultyAttributes_maxCombo(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeManiaDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____maxCombo;
    status = napi_create_int32(env, instance->maxCombo, &____maxCombo);
    assert(status == napi_ok);
    return ____maxCombo;
}

static napi_value setter_field_NativeManiaDifficultyAttributes_maxCombo
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeManiaDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __maxCombo;
    status = napi_get_value_int32(env, args[0], &__maxCombo);
    instance->maxCombo = (::int32_t)__maxCombo;
    return nullptr;
}

static napi_value register_class__NativeManiaDifficultyAttributes(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "starRating", nullptr, nullptr, getter_field_NativeManiaDifficultyAttributes_starRating, setter_field_NativeManiaDifficultyAttributes_starRating, nullptr, attributes, nullptr },
        { "maxCombo", nullptr, nullptr, getter_field_NativeManiaDifficultyAttributes_maxCombo, setter_field_NativeManiaDifficultyAttributes_maxCombo, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeManiaDifficultyAttributes", NAPI_AUTO_LENGTH, callback_method_NativeManiaDifficultyAttributes_NativeManiaDifficultyAttributes, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeManiaDifficultyAttributes_NativeManiaDifficultyAttributes);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeManiaDifficultyCalculator_NativeManiaDifficultyCalculator(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeManiaDifficultyCalculator_NativeManiaDifficultyCalculator;

// NativeManiaDifficultyCalculator::NativeManiaDifficultyCalculator
static napi_value callback_method_NativeManiaDifficultyCalculator_NativeManiaDifficultyCalculator(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeManiaDifficultyCalculator* instance = nullptr;

    instance = new NativeManiaDifficultyCalculator();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeManiaDifficultyCalculator_NativeManiaDifficultyCalculator, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeManiaDifficultyCalculator::__handle
static napi_value getter_field_NativeManiaDifficultyCalculator_handle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeManiaDifficultyCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____handle_ctor;
    status = napi_get_reference_value(env, ctor_ManagedObjectHandle_ManagedObjectHandle, &____handle_ctor);
    assert(status == napi_ok);

    napi_value ____handle_instance;
    status = napi_new_instance(env, ____handle_ctor, 0, nullptr, &____handle_instance);
    assert(status == napi_ok);

    ManagedObjectHandle* ____handle_native;
    status = napi_unwrap(env, ____handle_instance, (void**) &____handle_native);
    assert(status == napi_ok);
    *____handle_native = *&instance->handle;

    return ____handle_instance;
}

static napi_value setter_field_NativeManiaDifficultyCalculator_handle
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeManiaDifficultyCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    ManagedObjectHandle* __handle_instance;
    status = napi_unwrap(env, args[0], (void**) &__handle_instance);
    instance->handle = *__handle_instance;
    return nullptr;
}

static napi_value register_class__NativeManiaDifficultyCalculator(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "handle", nullptr, nullptr, getter_field_NativeManiaDifficultyCalculator_handle, setter_field_NativeManiaDifficultyCalculator_handle, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeManiaDifficultyCalculator", NAPI_AUTO_LENGTH, callback_method_NativeManiaDifficultyCalculator_NativeManiaDifficultyCalculator, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeManiaDifficultyCalculator_NativeManiaDifficultyCalculator);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeOsuDifficultyAttributes_NativeOsuDifficultyAttributes(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeOsuDifficultyAttributes_NativeOsuDifficultyAttributes;

// NativeOsuDifficultyAttributes::NativeOsuDifficultyAttributes
static napi_value callback_method_NativeOsuDifficultyAttributes_NativeOsuDifficultyAttributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeOsuDifficultyAttributes* instance = nullptr;

    instance = new NativeOsuDifficultyAttributes();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeOsuDifficultyAttributes_NativeOsuDifficultyAttributes, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeOsuDifficultyAttributes::__starRating
static napi_value getter_field_NativeOsuDifficultyAttributes_starRating(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____starRating;
    status = napi_create_double(env, instance->starRating, &____starRating);
    assert(status == napi_ok);
    return ____starRating;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_starRating
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __starRating;
    status = napi_get_value_double(env, args[0], &__starRating);
    instance->starRating = __starRating;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__maxCombo
static napi_value getter_field_NativeOsuDifficultyAttributes_maxCombo(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____maxCombo;
    status = napi_create_int32(env, instance->maxCombo, &____maxCombo);
    assert(status == napi_ok);
    return ____maxCombo;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_maxCombo
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __maxCombo;
    status = napi_get_value_int32(env, args[0], &__maxCombo);
    instance->maxCombo = (::int32_t)__maxCombo;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__aimDifficulty
static napi_value getter_field_NativeOsuDifficultyAttributes_aimDifficulty(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____aimDifficulty;
    status = napi_create_double(env, instance->aimDifficulty, &____aimDifficulty);
    assert(status == napi_ok);
    return ____aimDifficulty;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_aimDifficulty
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __aimDifficulty;
    status = napi_get_value_double(env, args[0], &__aimDifficulty);
    instance->aimDifficulty = __aimDifficulty;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__aimDifficultSliderCount
static napi_value getter_field_NativeOsuDifficultyAttributes_aimDifficultSliderCount(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____aimDifficultSliderCount;
    status = napi_create_double(env, instance->aimDifficultSliderCount, &____aimDifficultSliderCount);
    assert(status == napi_ok);
    return ____aimDifficultSliderCount;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_aimDifficultSliderCount
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __aimDifficultSliderCount;
    status = napi_get_value_double(env, args[0], &__aimDifficultSliderCount);
    instance->aimDifficultSliderCount = __aimDifficultSliderCount;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__speedDifficulty
static napi_value getter_field_NativeOsuDifficultyAttributes_speedDifficulty(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____speedDifficulty;
    status = napi_create_double(env, instance->speedDifficulty, &____speedDifficulty);
    assert(status == napi_ok);
    return ____speedDifficulty;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_speedDifficulty
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __speedDifficulty;
    status = napi_get_value_double(env, args[0], &__speedDifficulty);
    instance->speedDifficulty = __speedDifficulty;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__speedNoteCount
static napi_value getter_field_NativeOsuDifficultyAttributes_speedNoteCount(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____speedNoteCount;
    status = napi_create_double(env, instance->speedNoteCount, &____speedNoteCount);
    assert(status == napi_ok);
    return ____speedNoteCount;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_speedNoteCount
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __speedNoteCount;
    status = napi_get_value_double(env, args[0], &__speedNoteCount);
    instance->speedNoteCount = __speedNoteCount;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__flashlightDifficulty
static napi_value getter_field_NativeOsuDifficultyAttributes_flashlightDifficulty(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____flashlightDifficulty;
    status = napi_create_double(env, instance->flashlightDifficulty, &____flashlightDifficulty);
    assert(status == napi_ok);
    return ____flashlightDifficulty;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_flashlightDifficulty
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __flashlightDifficulty;
    status = napi_get_value_double(env, args[0], &__flashlightDifficulty);
    instance->flashlightDifficulty = __flashlightDifficulty;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__sliderFactor
static napi_value getter_field_NativeOsuDifficultyAttributes_sliderFactor(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____sliderFactor;
    status = napi_create_double(env, instance->sliderFactor, &____sliderFactor);
    assert(status == napi_ok);
    return ____sliderFactor;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_sliderFactor
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __sliderFactor;
    status = napi_get_value_double(env, args[0], &__sliderFactor);
    instance->sliderFactor = __sliderFactor;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__aimTopWeightedSliderFactor
static napi_value getter_field_NativeOsuDifficultyAttributes_aimTopWeightedSliderFactor(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____aimTopWeightedSliderFactor;
    status = napi_create_double(env, instance->aimTopWeightedSliderFactor, &____aimTopWeightedSliderFactor);
    assert(status == napi_ok);
    return ____aimTopWeightedSliderFactor;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_aimTopWeightedSliderFactor
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __aimTopWeightedSliderFactor;
    status = napi_get_value_double(env, args[0], &__aimTopWeightedSliderFactor);
    instance->aimTopWeightedSliderFactor = __aimTopWeightedSliderFactor;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__speedTopWeightedSliderFactor
static napi_value getter_field_NativeOsuDifficultyAttributes_speedTopWeightedSliderFactor(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____speedTopWeightedSliderFactor;
    status = napi_create_double(env, instance->speedTopWeightedSliderFactor, &____speedTopWeightedSliderFactor);
    assert(status == napi_ok);
    return ____speedTopWeightedSliderFactor;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_speedTopWeightedSliderFactor
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __speedTopWeightedSliderFactor;
    status = napi_get_value_double(env, args[0], &__speedTopWeightedSliderFactor);
    instance->speedTopWeightedSliderFactor = __speedTopWeightedSliderFactor;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__aimDifficultStrainCount
static napi_value getter_field_NativeOsuDifficultyAttributes_aimDifficultStrainCount(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____aimDifficultStrainCount;
    status = napi_create_double(env, instance->aimDifficultStrainCount, &____aimDifficultStrainCount);
    assert(status == napi_ok);
    return ____aimDifficultStrainCount;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_aimDifficultStrainCount
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __aimDifficultStrainCount;
    status = napi_get_value_double(env, args[0], &__aimDifficultStrainCount);
    instance->aimDifficultStrainCount = __aimDifficultStrainCount;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__speedDifficultStrainCount
static napi_value getter_field_NativeOsuDifficultyAttributes_speedDifficultStrainCount(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____speedDifficultStrainCount;
    status = napi_create_double(env, instance->speedDifficultStrainCount, &____speedDifficultStrainCount);
    assert(status == napi_ok);
    return ____speedDifficultStrainCount;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_speedDifficultStrainCount
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __speedDifficultStrainCount;
    status = napi_get_value_double(env, args[0], &__speedDifficultStrainCount);
    instance->speedDifficultStrainCount = __speedDifficultStrainCount;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__nestedScorePerObject
static napi_value getter_field_NativeOsuDifficultyAttributes_nestedScorePerObject(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____nestedScorePerObject;
    status = napi_create_double(env, instance->nestedScorePerObject, &____nestedScorePerObject);
    assert(status == napi_ok);
    return ____nestedScorePerObject;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_nestedScorePerObject
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __nestedScorePerObject;
    status = napi_get_value_double(env, args[0], &__nestedScorePerObject);
    instance->nestedScorePerObject = __nestedScorePerObject;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__legacyScoreBaseMultiplier
static napi_value getter_field_NativeOsuDifficultyAttributes_legacyScoreBaseMultiplier(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____legacyScoreBaseMultiplier;
    status = napi_create_double(env, instance->legacyScoreBaseMultiplier, &____legacyScoreBaseMultiplier);
    assert(status == napi_ok);
    return ____legacyScoreBaseMultiplier;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_legacyScoreBaseMultiplier
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __legacyScoreBaseMultiplier;
    status = napi_get_value_double(env, args[0], &__legacyScoreBaseMultiplier);
    instance->legacyScoreBaseMultiplier = __legacyScoreBaseMultiplier;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__maximumLegacyComboScore
static napi_value getter_field_NativeOsuDifficultyAttributes_maximumLegacyComboScore(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____maximumLegacyComboScore;
    status = napi_create_double(env, instance->maximumLegacyComboScore, &____maximumLegacyComboScore);
    assert(status == napi_ok);
    return ____maximumLegacyComboScore;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_maximumLegacyComboScore
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __maximumLegacyComboScore;
    status = napi_get_value_double(env, args[0], &__maximumLegacyComboScore);
    instance->maximumLegacyComboScore = __maximumLegacyComboScore;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__drainRate
static napi_value getter_field_NativeOsuDifficultyAttributes_drainRate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____drainRate;
    status = napi_create_double(env, instance->drainRate, &____drainRate);
    assert(status == napi_ok);
    return ____drainRate;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_drainRate
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __drainRate;
    status = napi_get_value_double(env, args[0], &__drainRate);
    instance->drainRate = __drainRate;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__hitCircleCount
static napi_value getter_field_NativeOsuDifficultyAttributes_hitCircleCount(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____hitCircleCount;
    status = napi_create_int32(env, instance->hitCircleCount, &____hitCircleCount);
    assert(status == napi_ok);
    return ____hitCircleCount;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_hitCircleCount
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __hitCircleCount;
    status = napi_get_value_int32(env, args[0], &__hitCircleCount);
    instance->hitCircleCount = (::int32_t)__hitCircleCount;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__sliderCount
static napi_value getter_field_NativeOsuDifficultyAttributes_sliderCount(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____sliderCount;
    status = napi_create_int32(env, instance->sliderCount, &____sliderCount);
    assert(status == napi_ok);
    return ____sliderCount;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_sliderCount
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __sliderCount;
    status = napi_get_value_int32(env, args[0], &__sliderCount);
    instance->sliderCount = (::int32_t)__sliderCount;
    return nullptr;
}

// NativeOsuDifficultyAttributes::__spinnerCount
static napi_value getter_field_NativeOsuDifficultyAttributes_spinnerCount(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____spinnerCount;
    status = napi_create_int32(env, instance->spinnerCount, &____spinnerCount);
    assert(status == napi_ok);
    return ____spinnerCount;
}

static napi_value setter_field_NativeOsuDifficultyAttributes_spinnerCount
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __spinnerCount;
    status = napi_get_value_int32(env, args[0], &__spinnerCount);
    instance->spinnerCount = (::int32_t)__spinnerCount;
    return nullptr;
}

static napi_value register_class__NativeOsuDifficultyAttributes(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "starRating", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_starRating, setter_field_NativeOsuDifficultyAttributes_starRating, nullptr, attributes, nullptr },
        { "maxCombo", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_maxCombo, setter_field_NativeOsuDifficultyAttributes_maxCombo, nullptr, attributes, nullptr },
        { "aimDifficulty", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_aimDifficulty, setter_field_NativeOsuDifficultyAttributes_aimDifficulty, nullptr, attributes, nullptr },
        { "aimDifficultSliderCount", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_aimDifficultSliderCount, setter_field_NativeOsuDifficultyAttributes_aimDifficultSliderCount, nullptr, attributes, nullptr },
        { "speedDifficulty", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_speedDifficulty, setter_field_NativeOsuDifficultyAttributes_speedDifficulty, nullptr, attributes, nullptr },
        { "speedNoteCount", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_speedNoteCount, setter_field_NativeOsuDifficultyAttributes_speedNoteCount, nullptr, attributes, nullptr },
        { "flashlightDifficulty", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_flashlightDifficulty, setter_field_NativeOsuDifficultyAttributes_flashlightDifficulty, nullptr, attributes, nullptr },
        { "sliderFactor", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_sliderFactor, setter_field_NativeOsuDifficultyAttributes_sliderFactor, nullptr, attributes, nullptr },
        { "aimTopWeightedSliderFactor", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_aimTopWeightedSliderFactor, setter_field_NativeOsuDifficultyAttributes_aimTopWeightedSliderFactor, nullptr, attributes, nullptr },
        { "speedTopWeightedSliderFactor", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_speedTopWeightedSliderFactor, setter_field_NativeOsuDifficultyAttributes_speedTopWeightedSliderFactor, nullptr, attributes, nullptr },
        { "aimDifficultStrainCount", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_aimDifficultStrainCount, setter_field_NativeOsuDifficultyAttributes_aimDifficultStrainCount, nullptr, attributes, nullptr },
        { "speedDifficultStrainCount", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_speedDifficultStrainCount, setter_field_NativeOsuDifficultyAttributes_speedDifficultStrainCount, nullptr, attributes, nullptr },
        { "nestedScorePerObject", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_nestedScorePerObject, setter_field_NativeOsuDifficultyAttributes_nestedScorePerObject, nullptr, attributes, nullptr },
        { "legacyScoreBaseMultiplier", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_legacyScoreBaseMultiplier, setter_field_NativeOsuDifficultyAttributes_legacyScoreBaseMultiplier, nullptr, attributes, nullptr },
        { "maximumLegacyComboScore", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_maximumLegacyComboScore, setter_field_NativeOsuDifficultyAttributes_maximumLegacyComboScore, nullptr, attributes, nullptr },
        { "drainRate", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_drainRate, setter_field_NativeOsuDifficultyAttributes_drainRate, nullptr, attributes, nullptr },
        { "hitCircleCount", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_hitCircleCount, setter_field_NativeOsuDifficultyAttributes_hitCircleCount, nullptr, attributes, nullptr },
        { "sliderCount", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_sliderCount, setter_field_NativeOsuDifficultyAttributes_sliderCount, nullptr, attributes, nullptr },
        { "spinnerCount", nullptr, nullptr, getter_field_NativeOsuDifficultyAttributes_spinnerCount, setter_field_NativeOsuDifficultyAttributes_spinnerCount, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeOsuDifficultyAttributes", NAPI_AUTO_LENGTH, callback_method_NativeOsuDifficultyAttributes_NativeOsuDifficultyAttributes, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeOsuDifficultyAttributes_NativeOsuDifficultyAttributes);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeOsuDifficultyCalculator_NativeOsuDifficultyCalculator(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeOsuDifficultyCalculator_NativeOsuDifficultyCalculator;

// NativeOsuDifficultyCalculator::NativeOsuDifficultyCalculator
static napi_value callback_method_NativeOsuDifficultyCalculator_NativeOsuDifficultyCalculator(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeOsuDifficultyCalculator* instance = nullptr;

    instance = new NativeOsuDifficultyCalculator();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeOsuDifficultyCalculator_NativeOsuDifficultyCalculator, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeOsuDifficultyCalculator::__handle
static napi_value getter_field_NativeOsuDifficultyCalculator_handle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____handle_ctor;
    status = napi_get_reference_value(env, ctor_ManagedObjectHandle_ManagedObjectHandle, &____handle_ctor);
    assert(status == napi_ok);

    napi_value ____handle_instance;
    status = napi_new_instance(env, ____handle_ctor, 0, nullptr, &____handle_instance);
    assert(status == napi_ok);

    ManagedObjectHandle* ____handle_native;
    status = napi_unwrap(env, ____handle_instance, (void**) &____handle_native);
    assert(status == napi_ok);
    *____handle_native = *&instance->handle;

    return ____handle_instance;
}

static napi_value setter_field_NativeOsuDifficultyCalculator_handle
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeOsuDifficultyCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    ManagedObjectHandle* __handle_instance;
    status = napi_unwrap(env, args[0], (void**) &__handle_instance);
    instance->handle = *__handle_instance;
    return nullptr;
}

static napi_value register_class__NativeOsuDifficultyCalculator(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "handle", nullptr, nullptr, getter_field_NativeOsuDifficultyCalculator_handle, setter_field_NativeOsuDifficultyCalculator_handle, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeOsuDifficultyCalculator", NAPI_AUTO_LENGTH, callback_method_NativeOsuDifficultyCalculator_NativeOsuDifficultyCalculator, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeOsuDifficultyCalculator_NativeOsuDifficultyCalculator);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeTaikoDifficultyAttributes_NativeTaikoDifficultyAttributes(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeTaikoDifficultyAttributes_NativeTaikoDifficultyAttributes;

// NativeTaikoDifficultyAttributes::NativeTaikoDifficultyAttributes
static napi_value callback_method_NativeTaikoDifficultyAttributes_NativeTaikoDifficultyAttributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeTaikoDifficultyAttributes* instance = nullptr;

    instance = new NativeTaikoDifficultyAttributes();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeTaikoDifficultyAttributes_NativeTaikoDifficultyAttributes, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeTaikoDifficultyAttributes::__starRating
static napi_value getter_field_NativeTaikoDifficultyAttributes_starRating(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____starRating;
    status = napi_create_double(env, instance->starRating, &____starRating);
    assert(status == napi_ok);
    return ____starRating;
}

static napi_value setter_field_NativeTaikoDifficultyAttributes_starRating
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __starRating;
    status = napi_get_value_double(env, args[0], &__starRating);
    instance->starRating = __starRating;
    return nullptr;
}

// NativeTaikoDifficultyAttributes::__maxCombo
static napi_value getter_field_NativeTaikoDifficultyAttributes_maxCombo(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____maxCombo;
    status = napi_create_int32(env, instance->maxCombo, &____maxCombo);
    assert(status == napi_ok);
    return ____maxCombo;
}

static napi_value setter_field_NativeTaikoDifficultyAttributes_maxCombo
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    int32_t __maxCombo;
    status = napi_get_value_int32(env, args[0], &__maxCombo);
    instance->maxCombo = (::int32_t)__maxCombo;
    return nullptr;
}

// NativeTaikoDifficultyAttributes::__mechanicalDifficulty
static napi_value getter_field_NativeTaikoDifficultyAttributes_mechanicalDifficulty(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____mechanicalDifficulty;
    status = napi_create_double(env, instance->mechanicalDifficulty, &____mechanicalDifficulty);
    assert(status == napi_ok);
    return ____mechanicalDifficulty;
}

static napi_value setter_field_NativeTaikoDifficultyAttributes_mechanicalDifficulty
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __mechanicalDifficulty;
    status = napi_get_value_double(env, args[0], &__mechanicalDifficulty);
    instance->mechanicalDifficulty = __mechanicalDifficulty;
    return nullptr;
}

// NativeTaikoDifficultyAttributes::__rhythmDifficulty
static napi_value getter_field_NativeTaikoDifficultyAttributes_rhythmDifficulty(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____rhythmDifficulty;
    status = napi_create_double(env, instance->rhythmDifficulty, &____rhythmDifficulty);
    assert(status == napi_ok);
    return ____rhythmDifficulty;
}

static napi_value setter_field_NativeTaikoDifficultyAttributes_rhythmDifficulty
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __rhythmDifficulty;
    status = napi_get_value_double(env, args[0], &__rhythmDifficulty);
    instance->rhythmDifficulty = __rhythmDifficulty;
    return nullptr;
}

// NativeTaikoDifficultyAttributes::__readingDifficulty
static napi_value getter_field_NativeTaikoDifficultyAttributes_readingDifficulty(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____readingDifficulty;
    status = napi_create_double(env, instance->readingDifficulty, &____readingDifficulty);
    assert(status == napi_ok);
    return ____readingDifficulty;
}

static napi_value setter_field_NativeTaikoDifficultyAttributes_readingDifficulty
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __readingDifficulty;
    status = napi_get_value_double(env, args[0], &__readingDifficulty);
    instance->readingDifficulty = __readingDifficulty;
    return nullptr;
}

// NativeTaikoDifficultyAttributes::__colourDifficulty
static napi_value getter_field_NativeTaikoDifficultyAttributes_colourDifficulty(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____colourDifficulty;
    status = napi_create_double(env, instance->colourDifficulty, &____colourDifficulty);
    assert(status == napi_ok);
    return ____colourDifficulty;
}

static napi_value setter_field_NativeTaikoDifficultyAttributes_colourDifficulty
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __colourDifficulty;
    status = napi_get_value_double(env, args[0], &__colourDifficulty);
    instance->colourDifficulty = __colourDifficulty;
    return nullptr;
}

// NativeTaikoDifficultyAttributes::__staminaDifficulty
static napi_value getter_field_NativeTaikoDifficultyAttributes_staminaDifficulty(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____staminaDifficulty;
    status = napi_create_double(env, instance->staminaDifficulty, &____staminaDifficulty);
    assert(status == napi_ok);
    return ____staminaDifficulty;
}

static napi_value setter_field_NativeTaikoDifficultyAttributes_staminaDifficulty
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __staminaDifficulty;
    status = napi_get_value_double(env, args[0], &__staminaDifficulty);
    instance->staminaDifficulty = __staminaDifficulty;
    return nullptr;
}

// NativeTaikoDifficultyAttributes::__monoStaminaFactor
static napi_value getter_field_NativeTaikoDifficultyAttributes_monoStaminaFactor(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____monoStaminaFactor;
    status = napi_create_double(env, instance->monoStaminaFactor, &____monoStaminaFactor);
    assert(status == napi_ok);
    return ____monoStaminaFactor;
}

static napi_value setter_field_NativeTaikoDifficultyAttributes_monoStaminaFactor
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __monoStaminaFactor;
    status = napi_get_value_double(env, args[0], &__monoStaminaFactor);
    instance->monoStaminaFactor = __monoStaminaFactor;
    return nullptr;
}

// NativeTaikoDifficultyAttributes::__consistencyFactor
static napi_value getter_field_NativeTaikoDifficultyAttributes_consistencyFactor(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____consistencyFactor;
    status = napi_create_double(env, instance->consistencyFactor, &____consistencyFactor);
    assert(status == napi_ok);
    return ____consistencyFactor;
}

static napi_value setter_field_NativeTaikoDifficultyAttributes_consistencyFactor
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __consistencyFactor;
    status = napi_get_value_double(env, args[0], &__consistencyFactor);
    instance->consistencyFactor = __consistencyFactor;
    return nullptr;
}

// NativeTaikoDifficultyAttributes::__staminaTopStrains
static napi_value getter_field_NativeTaikoDifficultyAttributes_staminaTopStrains(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____staminaTopStrains;
    status = napi_create_double(env, instance->staminaTopStrains, &____staminaTopStrains);
    assert(status == napi_ok);
    return ____staminaTopStrains;
}

static napi_value setter_field_NativeTaikoDifficultyAttributes_staminaTopStrains
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __staminaTopStrains;
    status = napi_get_value_double(env, args[0], &__staminaTopStrains);
    instance->staminaTopStrains = __staminaTopStrains;
    return nullptr;
}

static napi_value register_class__NativeTaikoDifficultyAttributes(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "starRating", nullptr, nullptr, getter_field_NativeTaikoDifficultyAttributes_starRating, setter_field_NativeTaikoDifficultyAttributes_starRating, nullptr, attributes, nullptr },
        { "maxCombo", nullptr, nullptr, getter_field_NativeTaikoDifficultyAttributes_maxCombo, setter_field_NativeTaikoDifficultyAttributes_maxCombo, nullptr, attributes, nullptr },
        { "mechanicalDifficulty", nullptr, nullptr, getter_field_NativeTaikoDifficultyAttributes_mechanicalDifficulty, setter_field_NativeTaikoDifficultyAttributes_mechanicalDifficulty, nullptr, attributes, nullptr },
        { "rhythmDifficulty", nullptr, nullptr, getter_field_NativeTaikoDifficultyAttributes_rhythmDifficulty, setter_field_NativeTaikoDifficultyAttributes_rhythmDifficulty, nullptr, attributes, nullptr },
        { "readingDifficulty", nullptr, nullptr, getter_field_NativeTaikoDifficultyAttributes_readingDifficulty, setter_field_NativeTaikoDifficultyAttributes_readingDifficulty, nullptr, attributes, nullptr },
        { "colourDifficulty", nullptr, nullptr, getter_field_NativeTaikoDifficultyAttributes_colourDifficulty, setter_field_NativeTaikoDifficultyAttributes_colourDifficulty, nullptr, attributes, nullptr },
        { "staminaDifficulty", nullptr, nullptr, getter_field_NativeTaikoDifficultyAttributes_staminaDifficulty, setter_field_NativeTaikoDifficultyAttributes_staminaDifficulty, nullptr, attributes, nullptr },
        { "monoStaminaFactor", nullptr, nullptr, getter_field_NativeTaikoDifficultyAttributes_monoStaminaFactor, setter_field_NativeTaikoDifficultyAttributes_monoStaminaFactor, nullptr, attributes, nullptr },
        { "consistencyFactor", nullptr, nullptr, getter_field_NativeTaikoDifficultyAttributes_consistencyFactor, setter_field_NativeTaikoDifficultyAttributes_consistencyFactor, nullptr, attributes, nullptr },
        { "staminaTopStrains", nullptr, nullptr, getter_field_NativeTaikoDifficultyAttributes_staminaTopStrains, setter_field_NativeTaikoDifficultyAttributes_staminaTopStrains, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeTaikoDifficultyAttributes", NAPI_AUTO_LENGTH, callback_method_NativeTaikoDifficultyAttributes_NativeTaikoDifficultyAttributes, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeTaikoDifficultyAttributes_NativeTaikoDifficultyAttributes);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeTaikoDifficultyCalculator_NativeTaikoDifficultyCalculator(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeTaikoDifficultyCalculator_NativeTaikoDifficultyCalculator;

// NativeTaikoDifficultyCalculator::NativeTaikoDifficultyCalculator
static napi_value callback_method_NativeTaikoDifficultyCalculator_NativeTaikoDifficultyCalculator(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeTaikoDifficultyCalculator* instance = nullptr;

    instance = new NativeTaikoDifficultyCalculator();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeTaikoDifficultyCalculator_NativeTaikoDifficultyCalculator, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeTaikoDifficultyCalculator::__handle
static napi_value getter_field_NativeTaikoDifficultyCalculator_handle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____handle_ctor;
    status = napi_get_reference_value(env, ctor_ManagedObjectHandle_ManagedObjectHandle, &____handle_ctor);
    assert(status == napi_ok);

    napi_value ____handle_instance;
    status = napi_new_instance(env, ____handle_ctor, 0, nullptr, &____handle_instance);
    assert(status == napi_ok);

    ManagedObjectHandle* ____handle_native;
    status = napi_unwrap(env, ____handle_instance, (void**) &____handle_native);
    assert(status == napi_ok);
    *____handle_native = *&instance->handle;

    return ____handle_instance;
}

static napi_value setter_field_NativeTaikoDifficultyCalculator_handle
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTaikoDifficultyCalculator* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    ManagedObjectHandle* __handle_instance;
    status = napi_unwrap(env, args[0], (void**) &__handle_instance);
    instance->handle = *__handle_instance;
    return nullptr;
}

static napi_value register_class__NativeTaikoDifficultyCalculator(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "handle", nullptr, nullptr, getter_field_NativeTaikoDifficultyCalculator_handle, setter_field_NativeTaikoDifficultyCalculator_handle, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeTaikoDifficultyCalculator", NAPI_AUTO_LENGTH, callback_method_NativeTaikoDifficultyCalculator_NativeTaikoDifficultyCalculator, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeTaikoDifficultyCalculator_NativeTaikoDifficultyCalculator);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeTimedCatchDifficultyAttributes_NativeTimedCatchDifficultyAttributes(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeTimedCatchDifficultyAttributes_NativeTimedCatchDifficultyAttributes;

// NativeTimedCatchDifficultyAttributes::NativeTimedCatchDifficultyAttributes
static napi_value callback_method_NativeTimedCatchDifficultyAttributes_NativeTimedCatchDifficultyAttributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeTimedCatchDifficultyAttributes* instance = nullptr;

    instance = new NativeTimedCatchDifficultyAttributes();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeTimedCatchDifficultyAttributes_NativeTimedCatchDifficultyAttributes, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeTimedCatchDifficultyAttributes::__time
static napi_value getter_field_NativeTimedCatchDifficultyAttributes_time(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedCatchDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____time;
    status = napi_create_double(env, instance->time, &____time);
    assert(status == napi_ok);
    return ____time;
}

static napi_value setter_field_NativeTimedCatchDifficultyAttributes_time
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedCatchDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __time;
    status = napi_get_value_double(env, args[0], &__time);
    instance->time = __time;
    return nullptr;
}

// NativeTimedCatchDifficultyAttributes::__attributes
static napi_value getter_field_NativeTimedCatchDifficultyAttributes_attributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedCatchDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____attributes_ctor;
    status = napi_get_reference_value(env, ctor_NativeCatchDifficultyAttributes_NativeCatchDifficultyAttributes, &____attributes_ctor);
    assert(status == napi_ok);

    napi_value ____attributes_instance;
    status = napi_new_instance(env, ____attributes_ctor, 0, nullptr, &____attributes_instance);
    assert(status == napi_ok);

    NativeCatchDifficultyAttributes* ____attributes_native;
    status = napi_unwrap(env, ____attributes_instance, (void**) &____attributes_native);
    assert(status == napi_ok);
    *____attributes_native = *&instance->attributes;

    return ____attributes_instance;
}

static napi_value setter_field_NativeTimedCatchDifficultyAttributes_attributes
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedCatchDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    NativeCatchDifficultyAttributes* __attributes_instance;
    status = napi_unwrap(env, args[0], (void**) &__attributes_instance);
    instance->attributes = *__attributes_instance;
    return nullptr;
}

static napi_value register_class__NativeTimedCatchDifficultyAttributes(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "time", nullptr, nullptr, getter_field_NativeTimedCatchDifficultyAttributes_time, setter_field_NativeTimedCatchDifficultyAttributes_time, nullptr, attributes, nullptr },
        { "attributes", nullptr, nullptr, getter_field_NativeTimedCatchDifficultyAttributes_attributes, setter_field_NativeTimedCatchDifficultyAttributes_attributes, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeTimedCatchDifficultyAttributes", NAPI_AUTO_LENGTH, callback_method_NativeTimedCatchDifficultyAttributes_NativeTimedCatchDifficultyAttributes, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeTimedCatchDifficultyAttributes_NativeTimedCatchDifficultyAttributes);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeTimedManiaDifficultyAttributes_NativeTimedManiaDifficultyAttributes(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeTimedManiaDifficultyAttributes_NativeTimedManiaDifficultyAttributes;

// NativeTimedManiaDifficultyAttributes::NativeTimedManiaDifficultyAttributes
static napi_value callback_method_NativeTimedManiaDifficultyAttributes_NativeTimedManiaDifficultyAttributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeTimedManiaDifficultyAttributes* instance = nullptr;

    instance = new NativeTimedManiaDifficultyAttributes();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeTimedManiaDifficultyAttributes_NativeTimedManiaDifficultyAttributes, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeTimedManiaDifficultyAttributes::__time
static napi_value getter_field_NativeTimedManiaDifficultyAttributes_time(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedManiaDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____time;
    status = napi_create_double(env, instance->time, &____time);
    assert(status == napi_ok);
    return ____time;
}

static napi_value setter_field_NativeTimedManiaDifficultyAttributes_time
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedManiaDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __time;
    status = napi_get_value_double(env, args[0], &__time);
    instance->time = __time;
    return nullptr;
}

// NativeTimedManiaDifficultyAttributes::__attributes
static napi_value getter_field_NativeTimedManiaDifficultyAttributes_attributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedManiaDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____attributes_ctor;
    status = napi_get_reference_value(env, ctor_NativeManiaDifficultyAttributes_NativeManiaDifficultyAttributes, &____attributes_ctor);
    assert(status == napi_ok);

    napi_value ____attributes_instance;
    status = napi_new_instance(env, ____attributes_ctor, 0, nullptr, &____attributes_instance);
    assert(status == napi_ok);

    NativeManiaDifficultyAttributes* ____attributes_native;
    status = napi_unwrap(env, ____attributes_instance, (void**) &____attributes_native);
    assert(status == napi_ok);
    *____attributes_native = *&instance->attributes;

    return ____attributes_instance;
}

static napi_value setter_field_NativeTimedManiaDifficultyAttributes_attributes
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedManiaDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    NativeManiaDifficultyAttributes* __attributes_instance;
    status = napi_unwrap(env, args[0], (void**) &__attributes_instance);
    instance->attributes = *__attributes_instance;
    return nullptr;
}

static napi_value register_class__NativeTimedManiaDifficultyAttributes(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "time", nullptr, nullptr, getter_field_NativeTimedManiaDifficultyAttributes_time, setter_field_NativeTimedManiaDifficultyAttributes_time, nullptr, attributes, nullptr },
        { "attributes", nullptr, nullptr, getter_field_NativeTimedManiaDifficultyAttributes_attributes, setter_field_NativeTimedManiaDifficultyAttributes_attributes, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeTimedManiaDifficultyAttributes", NAPI_AUTO_LENGTH, callback_method_NativeTimedManiaDifficultyAttributes_NativeTimedManiaDifficultyAttributes, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeTimedManiaDifficultyAttributes_NativeTimedManiaDifficultyAttributes);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeTimedOsuDifficultyAttributes_NativeTimedOsuDifficultyAttributes(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeTimedOsuDifficultyAttributes_NativeTimedOsuDifficultyAttributes;

// NativeTimedOsuDifficultyAttributes::NativeTimedOsuDifficultyAttributes
static napi_value callback_method_NativeTimedOsuDifficultyAttributes_NativeTimedOsuDifficultyAttributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeTimedOsuDifficultyAttributes* instance = nullptr;

    instance = new NativeTimedOsuDifficultyAttributes();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeTimedOsuDifficultyAttributes_NativeTimedOsuDifficultyAttributes, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeTimedOsuDifficultyAttributes::__time
static napi_value getter_field_NativeTimedOsuDifficultyAttributes_time(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____time;
    status = napi_create_double(env, instance->time, &____time);
    assert(status == napi_ok);
    return ____time;
}

static napi_value setter_field_NativeTimedOsuDifficultyAttributes_time
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __time;
    status = napi_get_value_double(env, args[0], &__time);
    instance->time = __time;
    return nullptr;
}

// NativeTimedOsuDifficultyAttributes::__attributes
static napi_value getter_field_NativeTimedOsuDifficultyAttributes_attributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____attributes_ctor;
    status = napi_get_reference_value(env, ctor_NativeOsuDifficultyAttributes_NativeOsuDifficultyAttributes, &____attributes_ctor);
    assert(status == napi_ok);

    napi_value ____attributes_instance;
    status = napi_new_instance(env, ____attributes_ctor, 0, nullptr, &____attributes_instance);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* ____attributes_native;
    status = napi_unwrap(env, ____attributes_instance, (void**) &____attributes_native);
    assert(status == napi_ok);
    *____attributes_native = *&instance->attributes;

    return ____attributes_instance;
}

static napi_value setter_field_NativeTimedOsuDifficultyAttributes_attributes
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedOsuDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    NativeOsuDifficultyAttributes* __attributes_instance;
    status = napi_unwrap(env, args[0], (void**) &__attributes_instance);
    instance->attributes = *__attributes_instance;
    return nullptr;
}

static napi_value register_class__NativeTimedOsuDifficultyAttributes(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "time", nullptr, nullptr, getter_field_NativeTimedOsuDifficultyAttributes_time, setter_field_NativeTimedOsuDifficultyAttributes_time, nullptr, attributes, nullptr },
        { "attributes", nullptr, nullptr, getter_field_NativeTimedOsuDifficultyAttributes_attributes, setter_field_NativeTimedOsuDifficultyAttributes_attributes, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeTimedOsuDifficultyAttributes", NAPI_AUTO_LENGTH, callback_method_NativeTimedOsuDifficultyAttributes_NativeTimedOsuDifficultyAttributes, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeTimedOsuDifficultyAttributes_NativeTimedOsuDifficultyAttributes);
    assert(status == napi_ok);

    return constructor;
}

static void dtor_NativeTimedTaikoDifficultyAttributes_NativeTimedTaikoDifficultyAttributes(napi_env env, void* finalize_data, void* finalize_hint)
{
}

static napi_ref ctor_NativeTimedTaikoDifficultyAttributes_NativeTimedTaikoDifficultyAttributes;

// NativeTimedTaikoDifficultyAttributes::NativeTimedTaikoDifficultyAttributes
static napi_value callback_method_NativeTimedTaikoDifficultyAttributes_NativeTimedTaikoDifficultyAttributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    NativeTimedTaikoDifficultyAttributes* instance = nullptr;

    instance = new NativeTimedTaikoDifficultyAttributes();
    napi_ref result;
    status = napi_wrap(env, _this, instance, dtor_NativeTimedTaikoDifficultyAttributes_NativeTimedTaikoDifficultyAttributes, nullptr, &result);
    assert(status == napi_ok);


    return _this;
}

// NativeTimedTaikoDifficultyAttributes::__time
static napi_value getter_field_NativeTimedTaikoDifficultyAttributes_time(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____time;
    status = napi_create_double(env, instance->time, &____time);
    assert(status == napi_ok);
    return ____time;
}

static napi_value setter_field_NativeTimedTaikoDifficultyAttributes_time
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    double __time;
    status = napi_get_value_double(env, args[0], &__time);
    instance->time = __time;
    return nullptr;
}

// NativeTimedTaikoDifficultyAttributes::__attributes
static napi_value getter_field_NativeTimedTaikoDifficultyAttributes_attributes(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    napi_value ____attributes_ctor;
    status = napi_get_reference_value(env, ctor_NativeTaikoDifficultyAttributes_NativeTaikoDifficultyAttributes, &____attributes_ctor);
    assert(status == napi_ok);

    napi_value ____attributes_instance;
    status = napi_new_instance(env, ____attributes_ctor, 0, nullptr, &____attributes_instance);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* ____attributes_native;
    status = napi_unwrap(env, ____attributes_instance, (void**) &____attributes_native);
    assert(status == napi_ok);
    *____attributes_native = *&instance->attributes;

    return ____attributes_instance;
}

static napi_value setter_field_NativeTimedTaikoDifficultyAttributes_attributes
(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc = 1;
    napi_value args[1];
    status = napi_get_cb_info(env, info, &argc, args, &_this, nullptr);
    assert(status == napi_ok);

    NativeTimedTaikoDifficultyAttributes* instance;
    status = napi_unwrap(env, _this, (void**) &instance);
    assert(status == napi_ok);

    NativeTaikoDifficultyAttributes* __attributes_instance;
    status = napi_unwrap(env, args[0], (void**) &__attributes_instance);
    instance->attributes = *__attributes_instance;
    return nullptr;
}

static napi_value register_class__NativeTimedTaikoDifficultyAttributes(napi_env env)
{
    napi_status status;
    napi_property_attributes attributes = (napi_property_attributes) (napi_default | napi_enumerable);
    napi_property_descriptor props[] =
    {
        // { utf8name, name, method, getter, setter, value, attributes, data }
        { "time", nullptr, nullptr, getter_field_NativeTimedTaikoDifficultyAttributes_time, setter_field_NativeTimedTaikoDifficultyAttributes_time, nullptr, attributes, nullptr },
        { "attributes", nullptr, nullptr, getter_field_NativeTimedTaikoDifficultyAttributes_attributes, setter_field_NativeTimedTaikoDifficultyAttributes_attributes, nullptr, attributes, nullptr },
    };

    napi_value constructor;
    status = napi_define_class(env, "NativeTimedTaikoDifficultyAttributes", NAPI_AUTO_LENGTH, callback_method_NativeTimedTaikoDifficultyAttributes_NativeTimedTaikoDifficultyAttributes, nullptr, sizeof(props) / sizeof(props[0]), props, &constructor);
    assert(status == napi_ok);

    status = napi_create_reference(env, constructor, 1, &ctor_NativeTimedTaikoDifficultyAttributes_NativeTimedTaikoDifficultyAttributes);
    assert(status == napi_ok);

    return constructor;
}

typedef ::ErrorCode ErrorCode;
typedef ::ManagedObjectHandle ManagedObjectHandle;
typedef ::NativeBeatmap NativeBeatmap;
typedef ::NativeMod NativeMod;
typedef ::NativeModsCollection NativeModsCollection;
typedef ::NativeRuleset NativeRuleset;
typedef ::NativeScoreInfo NativeScoreInfo;
typedef ::NativeCatchPerformanceAttributes NativeCatchPerformanceAttributes;
typedef ::NativeCatchPerformanceCalculator NativeCatchPerformanceCalculator;
typedef ::NativeManiaPerformanceAttributes NativeManiaPerformanceAttributes;
typedef ::NativeManiaPerformanceCalculator NativeManiaPerformanceCalculator;
typedef ::Cabinet__Nullable_double Cabinet__Nullable_double;
typedef ::NativeOsuPerformanceAttributes NativeOsuPerformanceAttributes;
typedef ::NativeOsuPerformanceCalculator NativeOsuPerformanceCalculator;
typedef ::NativeTaikoPerformanceAttributes NativeTaikoPerformanceAttributes;
typedef ::NativeTaikoPerformanceCalculator NativeTaikoPerformanceCalculator;
typedef ::NativeCatchDifficultyAttributes NativeCatchDifficultyAttributes;
typedef ::NativeCatchDifficultyCalculator NativeCatchDifficultyCalculator;
typedef ::NativeManiaDifficultyAttributes NativeManiaDifficultyAttributes;
typedef ::NativeManiaDifficultyCalculator NativeManiaDifficultyCalculator;
typedef ::NativeOsuDifficultyAttributes NativeOsuDifficultyAttributes;
typedef ::NativeOsuDifficultyCalculator NativeOsuDifficultyCalculator;
typedef ::NativeTaikoDifficultyAttributes NativeTaikoDifficultyAttributes;
typedef ::NativeTaikoDifficultyCalculator NativeTaikoDifficultyCalculator;
typedef ::NativeTimedCatchDifficultyAttributes NativeTimedCatchDifficultyAttributes;
typedef ::NativeTimedManiaDifficultyAttributes NativeTimedManiaDifficultyAttributes;
typedef ::NativeTimedOsuDifficultyAttributes NativeTimedOsuDifficultyAttributes;
typedef ::NativeTimedTaikoDifficultyAttributes NativeTimedTaikoDifficultyAttributes;

// ErrorHandler_GetLastMessage
static napi_value callback_function__ErrorHandler_GetLastMessage(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc > 0)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    const char* ___ret = ::ErrorHandler_GetLastMessage();

    napi_value _____ret;
    status = napi_create_string_utf8(env, ___ret, NAPI_AUTO_LENGTH, &_____ret);
    assert(status == napi_ok);

    return _____ret;

    return nullptr;
}

static napi_value register_function__ErrorHandler_GetLastMessage(napi_env env)
{
    napi_status status;
    napi_value __ErrorHandler_GetLastMessage;
    status = napi_create_function(env, "ErrorHandler_GetLastMessage", NAPI_AUTO_LENGTH, callback_function__ErrorHandler_GetLastMessage, 0, &__ErrorHandler_GetLastMessage);
    assert(status == napi_ok);

    return __ErrorHandler_GetLastMessage;
}

// Beatmap_CreateFromFile
static napi_value callback_function__Beatmap_CreateFromFile(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_NULL(types[0]) || types[0] == napi_string || NAPI_IS_BUFFER(args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Beatmap_CreateFromFile(uint8_t* filePathPtr, NativeBeatmap* nativeBeatmapPtr)
overload0:
    {
        napi_valuetype __filePathPtr_type;
        status = napi_typeof(env, args[0], &__filePathPtr_type);
        assert(status == napi_ok);
        bool __filePathPtr_is_buffer = false;
        status = napi_is_buffer(env, args[0], &__filePathPtr_is_buffer);
        assert(status == napi_ok);
        void* __filePathPtr_buffer_data = nullptr;
        size_t __filePathPtr_buffer_size = 0;
        if (__filePathPtr_is_buffer)
        {
            status = napi_get_buffer_info(env, args[0], &__filePathPtr_buffer_data, &__filePathPtr_buffer_size);
            assert(status == napi_ok);
        }
        size_t __filePathPtr_string_size = 0;
        char* __filePathPtr_string = nullptr;
        if (__filePathPtr_type == napi_string)
        {
            status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &__filePathPtr_string_size);
            assert(status == napi_ok);
            __filePathPtr_string = (char*) malloc(__filePathPtr_string_size + 1);
            status = napi_get_value_string_utf8(env, args[0], __filePathPtr_string, __filePathPtr_string_size + 1, &__filePathPtr_string_size);
            assert(status == napi_ok);
        }
        auto __arg0 = (uint8_t*)(__filePathPtr_type == napi_null ? nullptr : (__filePathPtr_is_buffer ? __filePathPtr_buffer_data : __filePathPtr_string));

        NativeBeatmap* nativeBeatmapPtr_instance;
        status = napi_unwrap(env, args[1], (void**) &nativeBeatmapPtr_instance);
        auto __arg1 = nativeBeatmapPtr_instance;

        ErrorCode ___ret = ::Beatmap_CreateFromFile(__arg0, __arg1);

        if (__filePathPtr_string != nullptr) free(__filePathPtr_string);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Beatmap_CreateFromFile(napi_env env)
{
    napi_status status;
    napi_value __Beatmap_CreateFromFile;
    status = napi_create_function(env, "Beatmap_CreateFromFile", NAPI_AUTO_LENGTH, callback_function__Beatmap_CreateFromFile, 0, &__Beatmap_CreateFromFile);
    assert(status == napi_ok);

    return __Beatmap_CreateFromFile;
}

// Beatmap_CreateFromText
static napi_value callback_function__Beatmap_CreateFromText(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_NULL(types[0]) || types[0] == napi_string || NAPI_IS_BUFFER(args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Beatmap_CreateFromText(uint8_t* beatmapTextPtr, NativeBeatmap* nativeBeatmapPtr)
overload0:
    {
        napi_valuetype __beatmapTextPtr_type;
        status = napi_typeof(env, args[0], &__beatmapTextPtr_type);
        assert(status == napi_ok);
        bool __beatmapTextPtr_is_buffer = false;
        status = napi_is_buffer(env, args[0], &__beatmapTextPtr_is_buffer);
        assert(status == napi_ok);
        void* __beatmapTextPtr_buffer_data = nullptr;
        size_t __beatmapTextPtr_buffer_size = 0;
        if (__beatmapTextPtr_is_buffer)
        {
            status = napi_get_buffer_info(env, args[0], &__beatmapTextPtr_buffer_data, &__beatmapTextPtr_buffer_size);
            assert(status == napi_ok);
        }
        size_t __beatmapTextPtr_string_size = 0;
        char* __beatmapTextPtr_string = nullptr;
        if (__beatmapTextPtr_type == napi_string)
        {
            status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &__beatmapTextPtr_string_size);
            assert(status == napi_ok);
            __beatmapTextPtr_string = (char*) malloc(__beatmapTextPtr_string_size + 1);
            status = napi_get_value_string_utf8(env, args[0], __beatmapTextPtr_string, __beatmapTextPtr_string_size + 1, &__beatmapTextPtr_string_size);
            assert(status == napi_ok);
        }
        auto __arg0 = (uint8_t*)(__beatmapTextPtr_type == napi_null ? nullptr : (__beatmapTextPtr_is_buffer ? __beatmapTextPtr_buffer_data : __beatmapTextPtr_string));

        NativeBeatmap* nativeBeatmapPtr_instance;
        status = napi_unwrap(env, args[1], (void**) &nativeBeatmapPtr_instance);
        auto __arg1 = nativeBeatmapPtr_instance;

        ErrorCode ___ret = ::Beatmap_CreateFromText(__arg0, __arg1);

        if (__beatmapTextPtr_string != nullptr) free(__beatmapTextPtr_string);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Beatmap_CreateFromText(napi_env env)
{
    napi_status status;
    napi_value __Beatmap_CreateFromText;
    status = napi_create_function(env, "Beatmap_CreateFromText", NAPI_AUTO_LENGTH, callback_function__Beatmap_CreateFromText, 0, &__Beatmap_CreateFromText);
    assert(status == napi_ok);

    return __Beatmap_CreateFromText;
}

// Beatmap_GetTitle
static napi_value callback_function__Beatmap_GetTitle(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_NULL(types[1]) || types[1] == napi_string || NAPI_IS_BUFFER(args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Beatmap_GetTitle(ManagedObjectHandle beatmapHandle, uint8_t* buffer, int32_t* bufferSize)
overload0:
    {
        ManagedObjectHandle* beatmapHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &beatmapHandle_instance);
        auto __arg0 = *beatmapHandle_instance;

        napi_valuetype __buffer_type;
        status = napi_typeof(env, args[1], &__buffer_type);
        assert(status == napi_ok);
        bool __buffer_is_buffer = false;
        status = napi_is_buffer(env, args[1], &__buffer_is_buffer);
        assert(status == napi_ok);
        void* __buffer_buffer_data = nullptr;
        size_t __buffer_buffer_size = 0;
        if (__buffer_is_buffer)
        {
            status = napi_get_buffer_info(env, args[1], &__buffer_buffer_data, &__buffer_buffer_size);
            assert(status == napi_ok);
        }
        size_t __buffer_string_size = 0;
        char* __buffer_string = nullptr;
        if (__buffer_type == napi_string)
        {
            status = napi_get_value_string_utf8(env, args[1], nullptr, 0, &__buffer_string_size);
            assert(status == napi_ok);
            __buffer_string = (char*) malloc(__buffer_string_size + 1);
            status = napi_get_value_string_utf8(env, args[1], __buffer_string, __buffer_string_size + 1, &__buffer_string_size);
            assert(status == napi_ok);
        }
        auto __arg1 = (uint8_t*)(__buffer_type == napi_null ? nullptr : (__buffer_is_buffer ? __buffer_buffer_data : __buffer_string));

        napi_typedarray_type __bufferSize_typedarray_type;
        size_t __bufferSize_typedarray_length;
        void* __bufferSize_typedarray_data;
        napi_value __bufferSize_typedarray_buffer;
        size_t __bufferSize_typedarray_offset;
        status = napi_get_typedarray_info(env, args[2], &__bufferSize_typedarray_type, &__bufferSize_typedarray_length, &__bufferSize_typedarray_data, &__bufferSize_typedarray_buffer, &__bufferSize_typedarray_offset);
        assert(status == napi_ok);
        assert(__bufferSize_typedarray_type == napi_int32_array);
        assert(__bufferSize_typedarray_length >= 1);
        int32_t* __arg2 = (int32_t*)__bufferSize_typedarray_data;
        ErrorCode ___ret = ::Beatmap_GetTitle(__arg0, __arg1, __arg2);

        if (__buffer_string != nullptr) free(__buffer_string);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Beatmap_GetTitle(napi_env env)
{
    napi_status status;
    napi_value __Beatmap_GetTitle;
    status = napi_create_function(env, "Beatmap_GetTitle", NAPI_AUTO_LENGTH, callback_function__Beatmap_GetTitle, 0, &__Beatmap_GetTitle);
    assert(status == napi_ok);

    return __Beatmap_GetTitle;
}

// Beatmap_GetArtist
static napi_value callback_function__Beatmap_GetArtist(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_NULL(types[1]) || types[1] == napi_string || NAPI_IS_BUFFER(args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Beatmap_GetArtist(ManagedObjectHandle beatmapHandle, uint8_t* buffer, int32_t* bufferSize)
overload0:
    {
        ManagedObjectHandle* beatmapHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &beatmapHandle_instance);
        auto __arg0 = *beatmapHandle_instance;

        napi_valuetype __buffer_type;
        status = napi_typeof(env, args[1], &__buffer_type);
        assert(status == napi_ok);
        bool __buffer_is_buffer = false;
        status = napi_is_buffer(env, args[1], &__buffer_is_buffer);
        assert(status == napi_ok);
        void* __buffer_buffer_data = nullptr;
        size_t __buffer_buffer_size = 0;
        if (__buffer_is_buffer)
        {
            status = napi_get_buffer_info(env, args[1], &__buffer_buffer_data, &__buffer_buffer_size);
            assert(status == napi_ok);
        }
        size_t __buffer_string_size = 0;
        char* __buffer_string = nullptr;
        if (__buffer_type == napi_string)
        {
            status = napi_get_value_string_utf8(env, args[1], nullptr, 0, &__buffer_string_size);
            assert(status == napi_ok);
            __buffer_string = (char*) malloc(__buffer_string_size + 1);
            status = napi_get_value_string_utf8(env, args[1], __buffer_string, __buffer_string_size + 1, &__buffer_string_size);
            assert(status == napi_ok);
        }
        auto __arg1 = (uint8_t*)(__buffer_type == napi_null ? nullptr : (__buffer_is_buffer ? __buffer_buffer_data : __buffer_string));

        napi_typedarray_type __bufferSize_typedarray_type;
        size_t __bufferSize_typedarray_length;
        void* __bufferSize_typedarray_data;
        napi_value __bufferSize_typedarray_buffer;
        size_t __bufferSize_typedarray_offset;
        status = napi_get_typedarray_info(env, args[2], &__bufferSize_typedarray_type, &__bufferSize_typedarray_length, &__bufferSize_typedarray_data, &__bufferSize_typedarray_buffer, &__bufferSize_typedarray_offset);
        assert(status == napi_ok);
        assert(__bufferSize_typedarray_type == napi_int32_array);
        assert(__bufferSize_typedarray_length >= 1);
        int32_t* __arg2 = (int32_t*)__bufferSize_typedarray_data;
        ErrorCode ___ret = ::Beatmap_GetArtist(__arg0, __arg1, __arg2);

        if (__buffer_string != nullptr) free(__buffer_string);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Beatmap_GetArtist(napi_env env)
{
    napi_status status;
    napi_value __Beatmap_GetArtist;
    status = napi_create_function(env, "Beatmap_GetArtist", NAPI_AUTO_LENGTH, callback_function__Beatmap_GetArtist, 0, &__Beatmap_GetArtist);
    assert(status == napi_ok);

    return __Beatmap_GetArtist;
}

// Beatmap_GetVersion
static napi_value callback_function__Beatmap_GetVersion(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_NULL(types[1]) || types[1] == napi_string || NAPI_IS_BUFFER(args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Beatmap_GetVersion(ManagedObjectHandle beatmapHandle, uint8_t* buffer, int32_t* bufferSize)
overload0:
    {
        ManagedObjectHandle* beatmapHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &beatmapHandle_instance);
        auto __arg0 = *beatmapHandle_instance;

        napi_valuetype __buffer_type;
        status = napi_typeof(env, args[1], &__buffer_type);
        assert(status == napi_ok);
        bool __buffer_is_buffer = false;
        status = napi_is_buffer(env, args[1], &__buffer_is_buffer);
        assert(status == napi_ok);
        void* __buffer_buffer_data = nullptr;
        size_t __buffer_buffer_size = 0;
        if (__buffer_is_buffer)
        {
            status = napi_get_buffer_info(env, args[1], &__buffer_buffer_data, &__buffer_buffer_size);
            assert(status == napi_ok);
        }
        size_t __buffer_string_size = 0;
        char* __buffer_string = nullptr;
        if (__buffer_type == napi_string)
        {
            status = napi_get_value_string_utf8(env, args[1], nullptr, 0, &__buffer_string_size);
            assert(status == napi_ok);
            __buffer_string = (char*) malloc(__buffer_string_size + 1);
            status = napi_get_value_string_utf8(env, args[1], __buffer_string, __buffer_string_size + 1, &__buffer_string_size);
            assert(status == napi_ok);
        }
        auto __arg1 = (uint8_t*)(__buffer_type == napi_null ? nullptr : (__buffer_is_buffer ? __buffer_buffer_data : __buffer_string));

        napi_typedarray_type __bufferSize_typedarray_type;
        size_t __bufferSize_typedarray_length;
        void* __bufferSize_typedarray_data;
        napi_value __bufferSize_typedarray_buffer;
        size_t __bufferSize_typedarray_offset;
        status = napi_get_typedarray_info(env, args[2], &__bufferSize_typedarray_type, &__bufferSize_typedarray_length, &__bufferSize_typedarray_data, &__bufferSize_typedarray_buffer, &__bufferSize_typedarray_offset);
        assert(status == napi_ok);
        assert(__bufferSize_typedarray_type == napi_int32_array);
        assert(__bufferSize_typedarray_length >= 1);
        int32_t* __arg2 = (int32_t*)__bufferSize_typedarray_data;
        ErrorCode ___ret = ::Beatmap_GetVersion(__arg0, __arg1, __arg2);

        if (__buffer_string != nullptr) free(__buffer_string);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Beatmap_GetVersion(napi_env env)
{
    napi_status status;
    napi_value __Beatmap_GetVersion;
    status = napi_create_function(env, "Beatmap_GetVersion", NAPI_AUTO_LENGTH, callback_function__Beatmap_GetVersion, 0, &__Beatmap_GetVersion);
    assert(status == napi_ok);

    return __Beatmap_GetVersion;
}

// Beatmap_Destroy
static napi_value callback_function__Beatmap_Destroy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Beatmap_Destroy(ManagedObjectHandle handle)
overload0:
    {
        ManagedObjectHandle* handle_instance;
        status = napi_unwrap(env, args[0], (void**) &handle_instance);
        auto __arg0 = *handle_instance;

        ErrorCode ___ret = ::Beatmap_Destroy(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Beatmap_Destroy(napi_env env)
{
    napi_status status;
    napi_value __Beatmap_Destroy;
    status = napi_create_function(env, "Beatmap_Destroy", NAPI_AUTO_LENGTH, callback_function__Beatmap_Destroy, 0, &__Beatmap_Destroy);
    assert(status == napi_ok);

    return __Beatmap_Destroy;
}

// Mod_Create
static napi_value callback_function__Mod_Create(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_NULL(types[0]) || types[0] == napi_string || NAPI_IS_BUFFER(args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Mod_Create(uint8_t* acronymPtr, NativeMod* nativeModPtr)
overload0:
    {
        napi_valuetype __acronymPtr_type;
        status = napi_typeof(env, args[0], &__acronymPtr_type);
        assert(status == napi_ok);
        bool __acronymPtr_is_buffer = false;
        status = napi_is_buffer(env, args[0], &__acronymPtr_is_buffer);
        assert(status == napi_ok);
        void* __acronymPtr_buffer_data = nullptr;
        size_t __acronymPtr_buffer_size = 0;
        if (__acronymPtr_is_buffer)
        {
            status = napi_get_buffer_info(env, args[0], &__acronymPtr_buffer_data, &__acronymPtr_buffer_size);
            assert(status == napi_ok);
        }
        size_t __acronymPtr_string_size = 0;
        char* __acronymPtr_string = nullptr;
        if (__acronymPtr_type == napi_string)
        {
            status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &__acronymPtr_string_size);
            assert(status == napi_ok);
            __acronymPtr_string = (char*) malloc(__acronymPtr_string_size + 1);
            status = napi_get_value_string_utf8(env, args[0], __acronymPtr_string, __acronymPtr_string_size + 1, &__acronymPtr_string_size);
            assert(status == napi_ok);
        }
        auto __arg0 = (uint8_t*)(__acronymPtr_type == napi_null ? nullptr : (__acronymPtr_is_buffer ? __acronymPtr_buffer_data : __acronymPtr_string));

        NativeMod* nativeModPtr_instance;
        status = napi_unwrap(env, args[1], (void**) &nativeModPtr_instance);
        auto __arg1 = nativeModPtr_instance;

        ErrorCode ___ret = ::Mod_Create(__arg0, __arg1);

        if (__acronymPtr_string != nullptr) free(__acronymPtr_string);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Mod_Create(napi_env env)
{
    napi_status status;
    napi_value __Mod_Create;
    status = napi_create_function(env, "Mod_Create", NAPI_AUTO_LENGTH, callback_function__Mod_Create, 0, &__Mod_Create);
    assert(status == napi_ok);

    return __Mod_Create;
}

// Mod_SetSettingBool
static napi_value callback_function__Mod_SetSettingBool(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_NULL(types[1]) || types[1] == napi_string || NAPI_IS_BUFFER(args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_BOOL(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Mod_SetSettingBool(ManagedObjectHandle modHandle, uint8_t* keyPtr, bool value)
overload0:
    {
        ManagedObjectHandle* modHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &modHandle_instance);
        auto __arg0 = *modHandle_instance;

        napi_valuetype __keyPtr_type;
        status = napi_typeof(env, args[1], &__keyPtr_type);
        assert(status == napi_ok);
        bool __keyPtr_is_buffer = false;
        status = napi_is_buffer(env, args[1], &__keyPtr_is_buffer);
        assert(status == napi_ok);
        void* __keyPtr_buffer_data = nullptr;
        size_t __keyPtr_buffer_size = 0;
        if (__keyPtr_is_buffer)
        {
            status = napi_get_buffer_info(env, args[1], &__keyPtr_buffer_data, &__keyPtr_buffer_size);
            assert(status == napi_ok);
        }
        size_t __keyPtr_string_size = 0;
        char* __keyPtr_string = nullptr;
        if (__keyPtr_type == napi_string)
        {
            status = napi_get_value_string_utf8(env, args[1], nullptr, 0, &__keyPtr_string_size);
            assert(status == napi_ok);
            __keyPtr_string = (char*) malloc(__keyPtr_string_size + 1);
            status = napi_get_value_string_utf8(env, args[1], __keyPtr_string, __keyPtr_string_size + 1, &__keyPtr_string_size);
            assert(status == napi_ok);
        }
        auto __arg1 = (uint8_t*)(__keyPtr_type == napi_null ? nullptr : (__keyPtr_is_buffer ? __keyPtr_buffer_data : __keyPtr_string));

        bool value;
        status = napi_get_value_bool(env, args[2], &value);
        auto __arg2 = (bool)value;

        ErrorCode ___ret = ::Mod_SetSettingBool(__arg0, __arg1, __arg2);

        if (__keyPtr_string != nullptr) free(__keyPtr_string);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Mod_SetSettingBool(napi_env env)
{
    napi_status status;
    napi_value __Mod_SetSettingBool;
    status = napi_create_function(env, "Mod_SetSettingBool", NAPI_AUTO_LENGTH, callback_function__Mod_SetSettingBool, 0, &__Mod_SetSettingBool);
    assert(status == napi_ok);

    return __Mod_SetSettingBool;
}

// Mod_SetSettingInteger
static napi_value callback_function__Mod_SetSettingInteger(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_NULL(types[1]) || types[1] == napi_string || NAPI_IS_BUFFER(args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_INT32(types[2], args[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Mod_SetSettingInteger(ManagedObjectHandle modHandle, uint8_t* keyPtr, int32_t value)
overload0:
    {
        ManagedObjectHandle* modHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &modHandle_instance);
        auto __arg0 = *modHandle_instance;

        napi_valuetype __keyPtr_type;
        status = napi_typeof(env, args[1], &__keyPtr_type);
        assert(status == napi_ok);
        bool __keyPtr_is_buffer = false;
        status = napi_is_buffer(env, args[1], &__keyPtr_is_buffer);
        assert(status == napi_ok);
        void* __keyPtr_buffer_data = nullptr;
        size_t __keyPtr_buffer_size = 0;
        if (__keyPtr_is_buffer)
        {
            status = napi_get_buffer_info(env, args[1], &__keyPtr_buffer_data, &__keyPtr_buffer_size);
            assert(status == napi_ok);
        }
        size_t __keyPtr_string_size = 0;
        char* __keyPtr_string = nullptr;
        if (__keyPtr_type == napi_string)
        {
            status = napi_get_value_string_utf8(env, args[1], nullptr, 0, &__keyPtr_string_size);
            assert(status == napi_ok);
            __keyPtr_string = (char*) malloc(__keyPtr_string_size + 1);
            status = napi_get_value_string_utf8(env, args[1], __keyPtr_string, __keyPtr_string_size + 1, &__keyPtr_string_size);
            assert(status == napi_ok);
        }
        auto __arg1 = (uint8_t*)(__keyPtr_type == napi_null ? nullptr : (__keyPtr_is_buffer ? __keyPtr_buffer_data : __keyPtr_string));

        int32_t value;
        status = napi_get_value_int32(env, args[2], &value);
        auto __arg2 = (::int32_t)value;

        ErrorCode ___ret = ::Mod_SetSettingInteger(__arg0, __arg1, __arg2);

        if (__keyPtr_string != nullptr) free(__keyPtr_string);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Mod_SetSettingInteger(napi_env env)
{
    napi_status status;
    napi_value __Mod_SetSettingInteger;
    status = napi_create_function(env, "Mod_SetSettingInteger", NAPI_AUTO_LENGTH, callback_function__Mod_SetSettingInteger, 0, &__Mod_SetSettingInteger);
    assert(status == napi_ok);

    return __Mod_SetSettingInteger;
}

// Mod_SetSettingFloat
static napi_value callback_function__Mod_SetSettingFloat(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_NULL(types[1]) || types[1] == napi_string || NAPI_IS_BUFFER(args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_NUMBER(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Mod_SetSettingFloat(ManagedObjectHandle modHandle, uint8_t* keyPtr, float value)
overload0:
    {
        ManagedObjectHandle* modHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &modHandle_instance);
        auto __arg0 = *modHandle_instance;

        napi_valuetype __keyPtr_type;
        status = napi_typeof(env, args[1], &__keyPtr_type);
        assert(status == napi_ok);
        bool __keyPtr_is_buffer = false;
        status = napi_is_buffer(env, args[1], &__keyPtr_is_buffer);
        assert(status == napi_ok);
        void* __keyPtr_buffer_data = nullptr;
        size_t __keyPtr_buffer_size = 0;
        if (__keyPtr_is_buffer)
        {
            status = napi_get_buffer_info(env, args[1], &__keyPtr_buffer_data, &__keyPtr_buffer_size);
            assert(status == napi_ok);
        }
        size_t __keyPtr_string_size = 0;
        char* __keyPtr_string = nullptr;
        if (__keyPtr_type == napi_string)
        {
            status = napi_get_value_string_utf8(env, args[1], nullptr, 0, &__keyPtr_string_size);
            assert(status == napi_ok);
            __keyPtr_string = (char*) malloc(__keyPtr_string_size + 1);
            status = napi_get_value_string_utf8(env, args[1], __keyPtr_string, __keyPtr_string_size + 1, &__keyPtr_string_size);
            assert(status == napi_ok);
        }
        auto __arg1 = (uint8_t*)(__keyPtr_type == napi_null ? nullptr : (__keyPtr_is_buffer ? __keyPtr_buffer_data : __keyPtr_string));

        double value;
        status = napi_get_value_double(env, args[2], &value);
        auto __arg2 = (float)value;

        ErrorCode ___ret = ::Mod_SetSettingFloat(__arg0, __arg1, __arg2);

        if (__keyPtr_string != nullptr) free(__keyPtr_string);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Mod_SetSettingFloat(napi_env env)
{
    napi_status status;
    napi_value __Mod_SetSettingFloat;
    status = napi_create_function(env, "Mod_SetSettingFloat", NAPI_AUTO_LENGTH, callback_function__Mod_SetSettingFloat, 0, &__Mod_SetSettingFloat);
    assert(status == napi_ok);

    return __Mod_SetSettingFloat;
}

// Mod_Debug
static napi_value callback_function__Mod_Debug(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Mod_Debug(ManagedObjectHandle modHandle)
overload0:
    {
        ManagedObjectHandle* modHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &modHandle_instance);
        auto __arg0 = *modHandle_instance;

        ErrorCode ___ret = ::Mod_Debug(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Mod_Debug(napi_env env)
{
    napi_status status;
    napi_value __Mod_Debug;
    status = napi_create_function(env, "Mod_Debug", NAPI_AUTO_LENGTH, callback_function__Mod_Debug, 0, &__Mod_Debug);
    assert(status == napi_ok);

    return __Mod_Debug;
}

// Mod_Destroy
static napi_value callback_function__Mod_Destroy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Mod_Destroy(ManagedObjectHandle handle)
overload0:
    {
        ManagedObjectHandle* handle_instance;
        status = napi_unwrap(env, args[0], (void**) &handle_instance);
        auto __arg0 = *handle_instance;

        ErrorCode ___ret = ::Mod_Destroy(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Mod_Destroy(napi_env env)
{
    napi_status status;
    napi_value __Mod_Destroy;
    status = napi_create_function(env, "Mod_Destroy", NAPI_AUTO_LENGTH, callback_function__Mod_Destroy, 0, &__Mod_Destroy);
    assert(status == napi_ok);

    return __Mod_Destroy;
}

// ModsCollection_Create
static napi_value callback_function__ModsCollection_Create(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode ModsCollection_Create(NativeModsCollection* nativeModsCollectionPtr)
overload0:
    {
        NativeModsCollection* nativeModsCollectionPtr_instance;
        status = napi_unwrap(env, args[0], (void**) &nativeModsCollectionPtr_instance);
        auto __arg0 = nativeModsCollectionPtr_instance;

        ErrorCode ___ret = ::ModsCollection_Create(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__ModsCollection_Create(napi_env env)
{
    napi_status status;
    napi_value __ModsCollection_Create;
    status = napi_create_function(env, "ModsCollection_Create", NAPI_AUTO_LENGTH, callback_function__ModsCollection_Create, 0, &__ModsCollection_Create);
    assert(status == napi_ok);

    return __ModsCollection_Create;
}

// ModsCollection_Add
static napi_value callback_function__ModsCollection_Add(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode ModsCollection_Add(ManagedObjectHandle modsCollectionHandle, ManagedObjectHandle modHandle)
overload0:
    {
        ManagedObjectHandle* modsCollectionHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &modsCollectionHandle_instance);
        auto __arg0 = *modsCollectionHandle_instance;

        ManagedObjectHandle* modHandle_instance;
        status = napi_unwrap(env, args[1], (void**) &modHandle_instance);
        auto __arg1 = *modHandle_instance;

        ErrorCode ___ret = ::ModsCollection_Add(__arg0, __arg1);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__ModsCollection_Add(napi_env env)
{
    napi_status status;
    napi_value __ModsCollection_Add;
    status = napi_create_function(env, "ModsCollection_Add", NAPI_AUTO_LENGTH, callback_function__ModsCollection_Add, 0, &__ModsCollection_Add);
    assert(status == napi_ok);

    return __ModsCollection_Add;
}

// ModsCollection_Remove
static napi_value callback_function__ModsCollection_Remove(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode ModsCollection_Remove(ManagedObjectHandle modsCollectionHandle, ManagedObjectHandle modHandle)
overload0:
    {
        ManagedObjectHandle* modsCollectionHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &modsCollectionHandle_instance);
        auto __arg0 = *modsCollectionHandle_instance;

        ManagedObjectHandle* modHandle_instance;
        status = napi_unwrap(env, args[1], (void**) &modHandle_instance);
        auto __arg1 = *modHandle_instance;

        ErrorCode ___ret = ::ModsCollection_Remove(__arg0, __arg1);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__ModsCollection_Remove(napi_env env)
{
    napi_status status;
    napi_value __ModsCollection_Remove;
    status = napi_create_function(env, "ModsCollection_Remove", NAPI_AUTO_LENGTH, callback_function__ModsCollection_Remove, 0, &__ModsCollection_Remove);
    assert(status == napi_ok);

    return __ModsCollection_Remove;
}

// ModsCollection_Debug
static napi_value callback_function__ModsCollection_Debug(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode ModsCollection_Debug(ManagedObjectHandle modsCollectionHandle)
overload0:
    {
        ManagedObjectHandle* modsCollectionHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &modsCollectionHandle_instance);
        auto __arg0 = *modsCollectionHandle_instance;

        ErrorCode ___ret = ::ModsCollection_Debug(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__ModsCollection_Debug(napi_env env)
{
    napi_status status;
    napi_value __ModsCollection_Debug;
    status = napi_create_function(env, "ModsCollection_Debug", NAPI_AUTO_LENGTH, callback_function__ModsCollection_Debug, 0, &__ModsCollection_Debug);
    assert(status == napi_ok);

    return __ModsCollection_Debug;
}

// ModsCollection_Destroy
static napi_value callback_function__ModsCollection_Destroy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode ModsCollection_Destroy(ManagedObjectHandle handle)
overload0:
    {
        ManagedObjectHandle* handle_instance;
        status = napi_unwrap(env, args[0], (void**) &handle_instance);
        auto __arg0 = *handle_instance;

        ErrorCode ___ret = ::ModsCollection_Destroy(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__ModsCollection_Destroy(napi_env env)
{
    napi_status status;
    napi_value __ModsCollection_Destroy;
    status = napi_create_function(env, "ModsCollection_Destroy", NAPI_AUTO_LENGTH, callback_function__ModsCollection_Destroy, 0, &__ModsCollection_Destroy);
    assert(status == napi_ok);

    return __ModsCollection_Destroy;
}

// Ruleset_CreateFromId
static napi_value callback_function__Ruleset_CreateFromId(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_INT32(types[0], args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Ruleset_CreateFromId(int32_t rulesetId, NativeRuleset* rulesetPtr)
overload0:
    {
        int32_t rulesetId;
        status = napi_get_value_int32(env, args[0], &rulesetId);
        auto __arg0 = (::int32_t)rulesetId;

        NativeRuleset* rulesetPtr_instance;
        status = napi_unwrap(env, args[1], (void**) &rulesetPtr_instance);
        auto __arg1 = rulesetPtr_instance;

        ErrorCode ___ret = ::Ruleset_CreateFromId(__arg0, __arg1);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Ruleset_CreateFromId(napi_env env)
{
    napi_status status;
    napi_value __Ruleset_CreateFromId;
    status = napi_create_function(env, "Ruleset_CreateFromId", NAPI_AUTO_LENGTH, callback_function__Ruleset_CreateFromId, 0, &__Ruleset_CreateFromId);
    assert(status == napi_ok);

    return __Ruleset_CreateFromId;
}

// Ruleset_CreateFromShortName
static napi_value callback_function__Ruleset_CreateFromShortName(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_NULL(types[0]) || types[0] == napi_string || NAPI_IS_BUFFER(args[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Ruleset_CreateFromShortName(uint8_t* shortName, NativeRuleset* rulesetPtr)
overload0:
    {
        napi_valuetype __shortName_type;
        status = napi_typeof(env, args[0], &__shortName_type);
        assert(status == napi_ok);
        bool __shortName_is_buffer = false;
        status = napi_is_buffer(env, args[0], &__shortName_is_buffer);
        assert(status == napi_ok);
        void* __shortName_buffer_data = nullptr;
        size_t __shortName_buffer_size = 0;
        if (__shortName_is_buffer)
        {
            status = napi_get_buffer_info(env, args[0], &__shortName_buffer_data, &__shortName_buffer_size);
            assert(status == napi_ok);
        }
        size_t __shortName_string_size = 0;
        char* __shortName_string = nullptr;
        if (__shortName_type == napi_string)
        {
            status = napi_get_value_string_utf8(env, args[0], nullptr, 0, &__shortName_string_size);
            assert(status == napi_ok);
            __shortName_string = (char*) malloc(__shortName_string_size + 1);
            status = napi_get_value_string_utf8(env, args[0], __shortName_string, __shortName_string_size + 1, &__shortName_string_size);
            assert(status == napi_ok);
        }
        auto __arg0 = (uint8_t*)(__shortName_type == napi_null ? nullptr : (__shortName_is_buffer ? __shortName_buffer_data : __shortName_string));

        NativeRuleset* rulesetPtr_instance;
        status = napi_unwrap(env, args[1], (void**) &rulesetPtr_instance);
        auto __arg1 = rulesetPtr_instance;

        ErrorCode ___ret = ::Ruleset_CreateFromShortName(__arg0, __arg1);

        if (__shortName_string != nullptr) free(__shortName_string);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Ruleset_CreateFromShortName(napi_env env)
{
    napi_status status;
    napi_value __Ruleset_CreateFromShortName;
    status = napi_create_function(env, "Ruleset_CreateFromShortName", NAPI_AUTO_LENGTH, callback_function__Ruleset_CreateFromShortName, 0, &__Ruleset_CreateFromShortName);
    assert(status == napi_ok);

    return __Ruleset_CreateFromShortName;
}

// Ruleset_GetShortName
static napi_value callback_function__Ruleset_GetShortName(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_NULL(types[1]) || types[1] == napi_string || NAPI_IS_BUFFER(args[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Ruleset_GetShortName(ManagedObjectHandle rulesetHandle, uint8_t* buffer, int32_t* bufferSize)
overload0:
    {
        ManagedObjectHandle* rulesetHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &rulesetHandle_instance);
        auto __arg0 = *rulesetHandle_instance;

        napi_valuetype __buffer_type;
        status = napi_typeof(env, args[1], &__buffer_type);
        assert(status == napi_ok);
        bool __buffer_is_buffer = false;
        status = napi_is_buffer(env, args[1], &__buffer_is_buffer);
        assert(status == napi_ok);
        void* __buffer_buffer_data = nullptr;
        size_t __buffer_buffer_size = 0;
        if (__buffer_is_buffer)
        {
            status = napi_get_buffer_info(env, args[1], &__buffer_buffer_data, &__buffer_buffer_size);
            assert(status == napi_ok);
        }
        size_t __buffer_string_size = 0;
        char* __buffer_string = nullptr;
        if (__buffer_type == napi_string)
        {
            status = napi_get_value_string_utf8(env, args[1], nullptr, 0, &__buffer_string_size);
            assert(status == napi_ok);
            __buffer_string = (char*) malloc(__buffer_string_size + 1);
            status = napi_get_value_string_utf8(env, args[1], __buffer_string, __buffer_string_size + 1, &__buffer_string_size);
            assert(status == napi_ok);
        }
        auto __arg1 = (uint8_t*)(__buffer_type == napi_null ? nullptr : (__buffer_is_buffer ? __buffer_buffer_data : __buffer_string));

        napi_typedarray_type __bufferSize_typedarray_type;
        size_t __bufferSize_typedarray_length;
        void* __bufferSize_typedarray_data;
        napi_value __bufferSize_typedarray_buffer;
        size_t __bufferSize_typedarray_offset;
        status = napi_get_typedarray_info(env, args[2], &__bufferSize_typedarray_type, &__bufferSize_typedarray_length, &__bufferSize_typedarray_data, &__bufferSize_typedarray_buffer, &__bufferSize_typedarray_offset);
        assert(status == napi_ok);
        assert(__bufferSize_typedarray_type == napi_int32_array);
        assert(__bufferSize_typedarray_length >= 1);
        int32_t* __arg2 = (int32_t*)__bufferSize_typedarray_data;
        ErrorCode ___ret = ::Ruleset_GetShortName(__arg0, __arg1, __arg2);

        if (__buffer_string != nullptr) free(__buffer_string);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Ruleset_GetShortName(napi_env env)
{
    napi_status status;
    napi_value __Ruleset_GetShortName;
    status = napi_create_function(env, "Ruleset_GetShortName", NAPI_AUTO_LENGTH, callback_function__Ruleset_GetShortName, 0, &__Ruleset_GetShortName);
    assert(status == napi_ok);

    return __Ruleset_GetShortName;
}

// Ruleset_Destroy
static napi_value callback_function__Ruleset_Destroy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode Ruleset_Destroy(ManagedObjectHandle handle)
overload0:
    {
        ManagedObjectHandle* handle_instance;
        status = napi_unwrap(env, args[0], (void**) &handle_instance);
        auto __arg0 = *handle_instance;

        ErrorCode ___ret = ::Ruleset_Destroy(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__Ruleset_Destroy(napi_env env)
{
    napi_status status;
    napi_value __Ruleset_Destroy;
    status = napi_create_function(env, "Ruleset_Destroy", NAPI_AUTO_LENGTH, callback_function__Ruleset_Destroy, 0, &__Ruleset_Destroy);
    assert(status == napi_ok);

    return __Ruleset_Destroy;
}

// CatchPerformanceCalculator_Create
static napi_value callback_function__CatchPerformanceCalculator_Create(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode CatchPerformanceCalculator_Create(NativeCatchPerformanceCalculator* nativeCatchPerformanceCalculatorPtr)
overload0:
    {
        NativeCatchPerformanceCalculator* nativeCatchPerformanceCalculatorPtr_instance;
        status = napi_unwrap(env, args[0], (void**) &nativeCatchPerformanceCalculatorPtr_instance);
        auto __arg0 = nativeCatchPerformanceCalculatorPtr_instance;

        ErrorCode ___ret = ::CatchPerformanceCalculator_Create(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__CatchPerformanceCalculator_Create(napi_env env)
{
    napi_status status;
    napi_value __CatchPerformanceCalculator_Create;
    status = napi_create_function(env, "CatchPerformanceCalculator_Create", NAPI_AUTO_LENGTH, callback_function__CatchPerformanceCalculator_Create, 0, &__CatchPerformanceCalculator_Create);
    assert(status == napi_ok);

    return __CatchPerformanceCalculator_Create;
}

// CatchPerformanceCalculator_Calculate
static napi_value callback_function__CatchPerformanceCalculator_Calculate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 4 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_OBJECT(types[3]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode CatchPerformanceCalculator_Calculate(ManagedObjectHandle calcHandle, NativeScoreInfo nativeScoreInfo, NativeCatchDifficultyAttributes nativeDifficultyAttributes, NativeCatchPerformanceAttributes* nativeAttributesPtr)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        NativeScoreInfo* nativeScoreInfo_instance;
        status = napi_unwrap(env, args[1], (void**) &nativeScoreInfo_instance);
        auto __arg1 = *nativeScoreInfo_instance;

        NativeCatchDifficultyAttributes* nativeDifficultyAttributes_instance;
        status = napi_unwrap(env, args[2], (void**) &nativeDifficultyAttributes_instance);
        auto __arg2 = *nativeDifficultyAttributes_instance;

        NativeCatchPerformanceAttributes* nativeAttributesPtr_instance;
        status = napi_unwrap(env, args[3], (void**) &nativeAttributesPtr_instance);
        auto __arg3 = nativeAttributesPtr_instance;

        ErrorCode ___ret = ::CatchPerformanceCalculator_Calculate(__arg0, __arg1, __arg2, __arg3);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__CatchPerformanceCalculator_Calculate(napi_env env)
{
    napi_status status;
    napi_value __CatchPerformanceCalculator_Calculate;
    status = napi_create_function(env, "CatchPerformanceCalculator_Calculate", NAPI_AUTO_LENGTH, callback_function__CatchPerformanceCalculator_Calculate, 0, &__CatchPerformanceCalculator_Calculate);
    assert(status == napi_ok);

    return __CatchPerformanceCalculator_Calculate;
}

// CatchPerformanceCalculator_Destroy
static napi_value callback_function__CatchPerformanceCalculator_Destroy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode CatchPerformanceCalculator_Destroy(ManagedObjectHandle handle)
overload0:
    {
        ManagedObjectHandle* handle_instance;
        status = napi_unwrap(env, args[0], (void**) &handle_instance);
        auto __arg0 = *handle_instance;

        ErrorCode ___ret = ::CatchPerformanceCalculator_Destroy(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__CatchPerformanceCalculator_Destroy(napi_env env)
{
    napi_status status;
    napi_value __CatchPerformanceCalculator_Destroy;
    status = napi_create_function(env, "CatchPerformanceCalculator_Destroy", NAPI_AUTO_LENGTH, callback_function__CatchPerformanceCalculator_Destroy, 0, &__CatchPerformanceCalculator_Destroy);
    assert(status == napi_ok);

    return __CatchPerformanceCalculator_Destroy;
}

// ManiaPerformanceCalculator_Create
static napi_value callback_function__ManiaPerformanceCalculator_Create(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode ManiaPerformanceCalculator_Create(NativeManiaPerformanceCalculator* nativeManiaPerformanceCalculatorPtr)
overload0:
    {
        NativeManiaPerformanceCalculator* nativeManiaPerformanceCalculatorPtr_instance;
        status = napi_unwrap(env, args[0], (void**) &nativeManiaPerformanceCalculatorPtr_instance);
        auto __arg0 = nativeManiaPerformanceCalculatorPtr_instance;

        ErrorCode ___ret = ::ManiaPerformanceCalculator_Create(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__ManiaPerformanceCalculator_Create(napi_env env)
{
    napi_status status;
    napi_value __ManiaPerformanceCalculator_Create;
    status = napi_create_function(env, "ManiaPerformanceCalculator_Create", NAPI_AUTO_LENGTH, callback_function__ManiaPerformanceCalculator_Create, 0, &__ManiaPerformanceCalculator_Create);
    assert(status == napi_ok);

    return __ManiaPerformanceCalculator_Create;
}

// ManiaPerformanceCalculator_Calculate
static napi_value callback_function__ManiaPerformanceCalculator_Calculate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 4 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_OBJECT(types[3]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode ManiaPerformanceCalculator_Calculate(ManagedObjectHandle calcHandle, NativeScoreInfo nativeScoreInfo, NativeManiaDifficultyAttributes nativeDifficultyAttributes, NativeManiaPerformanceAttributes* nativeAttributesPtr)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        NativeScoreInfo* nativeScoreInfo_instance;
        status = napi_unwrap(env, args[1], (void**) &nativeScoreInfo_instance);
        auto __arg1 = *nativeScoreInfo_instance;

        NativeManiaDifficultyAttributes* nativeDifficultyAttributes_instance;
        status = napi_unwrap(env, args[2], (void**) &nativeDifficultyAttributes_instance);
        auto __arg2 = *nativeDifficultyAttributes_instance;

        NativeManiaPerformanceAttributes* nativeAttributesPtr_instance;
        status = napi_unwrap(env, args[3], (void**) &nativeAttributesPtr_instance);
        auto __arg3 = nativeAttributesPtr_instance;

        ErrorCode ___ret = ::ManiaPerformanceCalculator_Calculate(__arg0, __arg1, __arg2, __arg3);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__ManiaPerformanceCalculator_Calculate(napi_env env)
{
    napi_status status;
    napi_value __ManiaPerformanceCalculator_Calculate;
    status = napi_create_function(env, "ManiaPerformanceCalculator_Calculate", NAPI_AUTO_LENGTH, callback_function__ManiaPerformanceCalculator_Calculate, 0, &__ManiaPerformanceCalculator_Calculate);
    assert(status == napi_ok);

    return __ManiaPerformanceCalculator_Calculate;
}

// ManiaPerformanceCalculator_Destroy
static napi_value callback_function__ManiaPerformanceCalculator_Destroy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode ManiaPerformanceCalculator_Destroy(ManagedObjectHandle handle)
overload0:
    {
        ManagedObjectHandle* handle_instance;
        status = napi_unwrap(env, args[0], (void**) &handle_instance);
        auto __arg0 = *handle_instance;

        ErrorCode ___ret = ::ManiaPerformanceCalculator_Destroy(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__ManiaPerformanceCalculator_Destroy(napi_env env)
{
    napi_status status;
    napi_value __ManiaPerformanceCalculator_Destroy;
    status = napi_create_function(env, "ManiaPerformanceCalculator_Destroy", NAPI_AUTO_LENGTH, callback_function__ManiaPerformanceCalculator_Destroy, 0, &__ManiaPerformanceCalculator_Destroy);
    assert(status == napi_ok);

    return __ManiaPerformanceCalculator_Destroy;
}

// OsuPerformanceCalculator_Create
static napi_value callback_function__OsuPerformanceCalculator_Create(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode OsuPerformanceCalculator_Create(NativeOsuPerformanceCalculator* nativeOsuPerformanceCalculatorPtr)
overload0:
    {
        NativeOsuPerformanceCalculator* nativeOsuPerformanceCalculatorPtr_instance;
        status = napi_unwrap(env, args[0], (void**) &nativeOsuPerformanceCalculatorPtr_instance);
        auto __arg0 = nativeOsuPerformanceCalculatorPtr_instance;

        ErrorCode ___ret = ::OsuPerformanceCalculator_Create(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__OsuPerformanceCalculator_Create(napi_env env)
{
    napi_status status;
    napi_value __OsuPerformanceCalculator_Create;
    status = napi_create_function(env, "OsuPerformanceCalculator_Create", NAPI_AUTO_LENGTH, callback_function__OsuPerformanceCalculator_Create, 0, &__OsuPerformanceCalculator_Create);
    assert(status == napi_ok);

    return __OsuPerformanceCalculator_Create;
}

// OsuPerformanceCalculator_Calculate
static napi_value callback_function__OsuPerformanceCalculator_Calculate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 4 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_OBJECT(types[3]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode OsuPerformanceCalculator_Calculate(ManagedObjectHandle calcHandle, NativeScoreInfo nativeScoreInfo, NativeOsuDifficultyAttributes nativeDifficultyAttributes, NativeOsuPerformanceAttributes* nativeAttributesPtr)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        NativeScoreInfo* nativeScoreInfo_instance;
        status = napi_unwrap(env, args[1], (void**) &nativeScoreInfo_instance);
        auto __arg1 = *nativeScoreInfo_instance;

        NativeOsuDifficultyAttributes* nativeDifficultyAttributes_instance;
        status = napi_unwrap(env, args[2], (void**) &nativeDifficultyAttributes_instance);
        auto __arg2 = *nativeDifficultyAttributes_instance;

        NativeOsuPerformanceAttributes* nativeAttributesPtr_instance;
        status = napi_unwrap(env, args[3], (void**) &nativeAttributesPtr_instance);
        auto __arg3 = nativeAttributesPtr_instance;

        ErrorCode ___ret = ::OsuPerformanceCalculator_Calculate(__arg0, __arg1, __arg2, __arg3);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__OsuPerformanceCalculator_Calculate(napi_env env)
{
    napi_status status;
    napi_value __OsuPerformanceCalculator_Calculate;
    status = napi_create_function(env, "OsuPerformanceCalculator_Calculate", NAPI_AUTO_LENGTH, callback_function__OsuPerformanceCalculator_Calculate, 0, &__OsuPerformanceCalculator_Calculate);
    assert(status == napi_ok);

    return __OsuPerformanceCalculator_Calculate;
}

// OsuPerformanceCalculator_Destroy
static napi_value callback_function__OsuPerformanceCalculator_Destroy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode OsuPerformanceCalculator_Destroy(ManagedObjectHandle handle)
overload0:
    {
        ManagedObjectHandle* handle_instance;
        status = napi_unwrap(env, args[0], (void**) &handle_instance);
        auto __arg0 = *handle_instance;

        ErrorCode ___ret = ::OsuPerformanceCalculator_Destroy(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__OsuPerformanceCalculator_Destroy(napi_env env)
{
    napi_status status;
    napi_value __OsuPerformanceCalculator_Destroy;
    status = napi_create_function(env, "OsuPerformanceCalculator_Destroy", NAPI_AUTO_LENGTH, callback_function__OsuPerformanceCalculator_Destroy, 0, &__OsuPerformanceCalculator_Destroy);
    assert(status == napi_ok);

    return __OsuPerformanceCalculator_Destroy;
}

// TaikoPerformanceCalculator_Create
static napi_value callback_function__TaikoPerformanceCalculator_Create(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode TaikoPerformanceCalculator_Create(NativeTaikoPerformanceCalculator* nativeTaikoPerformanceCalculatorPtr)
overload0:
    {
        NativeTaikoPerformanceCalculator* nativeTaikoPerformanceCalculatorPtr_instance;
        status = napi_unwrap(env, args[0], (void**) &nativeTaikoPerformanceCalculatorPtr_instance);
        auto __arg0 = nativeTaikoPerformanceCalculatorPtr_instance;

        ErrorCode ___ret = ::TaikoPerformanceCalculator_Create(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__TaikoPerformanceCalculator_Create(napi_env env)
{
    napi_status status;
    napi_value __TaikoPerformanceCalculator_Create;
    status = napi_create_function(env, "TaikoPerformanceCalculator_Create", NAPI_AUTO_LENGTH, callback_function__TaikoPerformanceCalculator_Create, 0, &__TaikoPerformanceCalculator_Create);
    assert(status == napi_ok);

    return __TaikoPerformanceCalculator_Create;
}

// TaikoPerformanceCalculator_Calculate
static napi_value callback_function__TaikoPerformanceCalculator_Calculate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 4 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_OBJECT(types[3]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode TaikoPerformanceCalculator_Calculate(ManagedObjectHandle calcHandle, NativeScoreInfo nativeScoreInfo, NativeTaikoDifficultyAttributes nativeDifficultyAttributes, NativeTaikoPerformanceAttributes* nativeAttributesPtr)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        NativeScoreInfo* nativeScoreInfo_instance;
        status = napi_unwrap(env, args[1], (void**) &nativeScoreInfo_instance);
        auto __arg1 = *nativeScoreInfo_instance;

        NativeTaikoDifficultyAttributes* nativeDifficultyAttributes_instance;
        status = napi_unwrap(env, args[2], (void**) &nativeDifficultyAttributes_instance);
        auto __arg2 = *nativeDifficultyAttributes_instance;

        NativeTaikoPerformanceAttributes* nativeAttributesPtr_instance;
        status = napi_unwrap(env, args[3], (void**) &nativeAttributesPtr_instance);
        auto __arg3 = nativeAttributesPtr_instance;

        ErrorCode ___ret = ::TaikoPerformanceCalculator_Calculate(__arg0, __arg1, __arg2, __arg3);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__TaikoPerformanceCalculator_Calculate(napi_env env)
{
    napi_status status;
    napi_value __TaikoPerformanceCalculator_Calculate;
    status = napi_create_function(env, "TaikoPerformanceCalculator_Calculate", NAPI_AUTO_LENGTH, callback_function__TaikoPerformanceCalculator_Calculate, 0, &__TaikoPerformanceCalculator_Calculate);
    assert(status == napi_ok);

    return __TaikoPerformanceCalculator_Calculate;
}

// TaikoPerformanceCalculator_Destroy
static napi_value callback_function__TaikoPerformanceCalculator_Destroy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode TaikoPerformanceCalculator_Destroy(ManagedObjectHandle handle)
overload0:
    {
        ManagedObjectHandle* handle_instance;
        status = napi_unwrap(env, args[0], (void**) &handle_instance);
        auto __arg0 = *handle_instance;

        ErrorCode ___ret = ::TaikoPerformanceCalculator_Destroy(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__TaikoPerformanceCalculator_Destroy(napi_env env)
{
    napi_status status;
    napi_value __TaikoPerformanceCalculator_Destroy;
    status = napi_create_function(env, "TaikoPerformanceCalculator_Destroy", NAPI_AUTO_LENGTH, callback_function__TaikoPerformanceCalculator_Destroy, 0, &__TaikoPerformanceCalculator_Destroy);
    assert(status == napi_ok);

    return __TaikoPerformanceCalculator_Destroy;
}

// CatchDifficultyCalculator_Create
static napi_value callback_function__CatchDifficultyCalculator_Create(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode CatchDifficultyCalculator_Create(ManagedObjectHandle rulesetHandle, ManagedObjectHandle beatmapHandle, NativeCatchDifficultyCalculator* nativeCatchDifficultyCalculatorPtr)
overload0:
    {
        ManagedObjectHandle* rulesetHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &rulesetHandle_instance);
        auto __arg0 = *rulesetHandle_instance;

        ManagedObjectHandle* beatmapHandle_instance;
        status = napi_unwrap(env, args[1], (void**) &beatmapHandle_instance);
        auto __arg1 = *beatmapHandle_instance;

        NativeCatchDifficultyCalculator* nativeCatchDifficultyCalculatorPtr_instance;
        status = napi_unwrap(env, args[2], (void**) &nativeCatchDifficultyCalculatorPtr_instance);
        auto __arg2 = nativeCatchDifficultyCalculatorPtr_instance;

        ErrorCode ___ret = ::CatchDifficultyCalculator_Create(__arg0, __arg1, __arg2);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__CatchDifficultyCalculator_Create(napi_env env)
{
    napi_status status;
    napi_value __CatchDifficultyCalculator_Create;
    status = napi_create_function(env, "CatchDifficultyCalculator_Create", NAPI_AUTO_LENGTH, callback_function__CatchDifficultyCalculator_Create, 0, &__CatchDifficultyCalculator_Create);
    assert(status == napi_ok);

    return __CatchDifficultyCalculator_Create;
}

// CatchDifficultyCalculator_Calculate
static napi_value callback_function__CatchDifficultyCalculator_Calculate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode CatchDifficultyCalculator_Calculate(ManagedObjectHandle calcHandle, NativeCatchDifficultyAttributes* nativeAttributesPtr)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        NativeCatchDifficultyAttributes* nativeAttributesPtr_instance;
        status = napi_unwrap(env, args[1], (void**) &nativeAttributesPtr_instance);
        auto __arg1 = nativeAttributesPtr_instance;

        ErrorCode ___ret = ::CatchDifficultyCalculator_Calculate(__arg0, __arg1);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__CatchDifficultyCalculator_Calculate(napi_env env)
{
    napi_status status;
    napi_value __CatchDifficultyCalculator_Calculate;
    status = napi_create_function(env, "CatchDifficultyCalculator_Calculate", NAPI_AUTO_LENGTH, callback_function__CatchDifficultyCalculator_Calculate, 0, &__CatchDifficultyCalculator_Calculate);
    assert(status == napi_ok);

    return __CatchDifficultyCalculator_Calculate;
}

// CatchDifficultyCalculator_CalculateMods
static napi_value callback_function__CatchDifficultyCalculator_CalculateMods(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode CatchDifficultyCalculator_CalculateMods(ManagedObjectHandle calcHandle, ManagedObjectHandle modsHandle, NativeCatchDifficultyAttributes* nativeAttributesPtr)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        ManagedObjectHandle* modsHandle_instance;
        status = napi_unwrap(env, args[1], (void**) &modsHandle_instance);
        auto __arg1 = *modsHandle_instance;

        NativeCatchDifficultyAttributes* nativeAttributesPtr_instance;
        status = napi_unwrap(env, args[2], (void**) &nativeAttributesPtr_instance);
        auto __arg2 = nativeAttributesPtr_instance;

        ErrorCode ___ret = ::CatchDifficultyCalculator_CalculateMods(__arg0, __arg1, __arg2);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__CatchDifficultyCalculator_CalculateMods(napi_env env)
{
    napi_status status;
    napi_value __CatchDifficultyCalculator_CalculateMods;
    status = napi_create_function(env, "CatchDifficultyCalculator_CalculateMods", NAPI_AUTO_LENGTH, callback_function__CatchDifficultyCalculator_CalculateMods, 0, &__CatchDifficultyCalculator_CalculateMods);
    assert(status == napi_ok);

    return __CatchDifficultyCalculator_CalculateMods;
}

// CatchDifficultyCalculator_CalculateTimed
static napi_value callback_function__CatchDifficultyCalculator_CalculateTimed(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_NULL(types[1]) || NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode CatchDifficultyCalculator_CalculateTimed(ManagedObjectHandle calcHandle, NativeTimedCatchDifficultyAttributes* nativeTimedAttributesBuffer, int32_t* bufferSize)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        napi_valuetype __nativeTimedAttributesBuffer_type;
        status = napi_typeof(env, args[1], &__nativeTimedAttributesBuffer_type);
        assert(status == napi_ok);
        bool __nativeTimedAttributesBuffer_is_null = __nativeTimedAttributesBuffer_type == napi_null;

        int32_t* __nativeTimedAttributesBuffer_bufferSize_ptr = nullptr;
        int32_t __nativeTimedAttributesBuffer_buffer_count = 0;
        std::vector<NativeTimedCatchDifficultyAttributes> __nativeTimedAttributesBuffer_buffer;

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            napi_typedarray_type __nativeTimedAttributesBuffer_bufferSize_typedarray_type;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_length;
            void* __nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            napi_value __nativeTimedAttributesBuffer_bufferSize_typedarray_buffer;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_offset;
            status = napi_get_typedarray_info(env, args[2], &__nativeTimedAttributesBuffer_bufferSize_typedarray_type, &__nativeTimedAttributesBuffer_bufferSize_typedarray_length, &__nativeTimedAttributesBuffer_bufferSize_typedarray_data, &__nativeTimedAttributesBuffer_bufferSize_typedarray_buffer, &__nativeTimedAttributesBuffer_bufferSize_typedarray_offset);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_type == napi_int32_array);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_length >= 1);
            __nativeTimedAttributesBuffer_bufferSize_ptr = (int32_t*)__nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            __nativeTimedAttributesBuffer_buffer_count = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            assert(__nativeTimedAttributesBuffer_buffer_count >= 0);

            bool __nativeTimedAttributesBuffer_is_array = false;
            status = napi_is_array(env, args[1], &__nativeTimedAttributesBuffer_is_array);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_is_array);

            __nativeTimedAttributesBuffer_buffer.resize((size_t)__nativeTimedAttributesBuffer_buffer_count);
        }

        auto __arg1 = (NativeTimedCatchDifficultyAttributes*)(__nativeTimedAttributesBuffer_is_null || __nativeTimedAttributesBuffer_buffer_count == 0 ? nullptr : __nativeTimedAttributesBuffer_buffer.data());

        napi_typedarray_type __bufferSize_typedarray_type;
        size_t __bufferSize_typedarray_length;
        void* __bufferSize_typedarray_data;
        napi_value __bufferSize_typedarray_buffer;
        size_t __bufferSize_typedarray_offset;
        status = napi_get_typedarray_info(env, args[2], &__bufferSize_typedarray_type, &__bufferSize_typedarray_length, &__bufferSize_typedarray_data, &__bufferSize_typedarray_buffer, &__bufferSize_typedarray_offset);
        assert(status == napi_ok);
        assert(__bufferSize_typedarray_type == napi_int32_array);
        assert(__bufferSize_typedarray_length >= 1);
        int32_t* __arg2 = (int32_t*)__bufferSize_typedarray_data;
        ErrorCode ___ret = ::CatchDifficultyCalculator_CalculateTimed(__arg0, __arg1, __arg2);

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            int32_t __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            if (__nativeTimedAttributesBuffer_written < 0) __nativeTimedAttributesBuffer_written = 0;
            if (__nativeTimedAttributesBuffer_written > __nativeTimedAttributesBuffer_buffer_count) __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_buffer_count;

            napi_value __nativeTimedAttributesBuffer_ctor;
            status = napi_get_reference_value(env, ctor_NativeTimedCatchDifficultyAttributes_NativeTimedCatchDifficultyAttributes, &__nativeTimedAttributesBuffer_ctor);
            assert(status == napi_ok);

            for (int32_t i = 0; i < __nativeTimedAttributesBuffer_written; i++)
            {
                napi_value __nativeTimedAttributesBuffer_instance;
                status = napi_new_instance(env, __nativeTimedAttributesBuffer_ctor, 0, nullptr, &__nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
                NativeTimedCatchDifficultyAttributes* __nativeTimedAttributesBuffer_native;
                status = napi_unwrap(env, __nativeTimedAttributesBuffer_instance, (void**) &__nativeTimedAttributesBuffer_native);
                assert(status == napi_ok);
                *__nativeTimedAttributesBuffer_native = __nativeTimedAttributesBuffer_buffer[(size_t)i];
                status = napi_set_element(env, args[1], (uint32_t)i, __nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
            }
        }

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__CatchDifficultyCalculator_CalculateTimed(napi_env env)
{
    napi_status status;
    napi_value __CatchDifficultyCalculator_CalculateTimed;
    status = napi_create_function(env, "CatchDifficultyCalculator_CalculateTimed", NAPI_AUTO_LENGTH, callback_function__CatchDifficultyCalculator_CalculateTimed, 0, &__CatchDifficultyCalculator_CalculateTimed);
    assert(status == napi_ok);

    return __CatchDifficultyCalculator_CalculateTimed;
}

// CatchDifficultyCalculator_CalculateModsTimed
static napi_value callback_function__CatchDifficultyCalculator_CalculateModsTimed(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 4 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_NULL(types[2]) || NAPI_IS_OBJECT(types[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_OBJECT(types[3]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode CatchDifficultyCalculator_CalculateModsTimed(ManagedObjectHandle calcHandle, ManagedObjectHandle modsHandle, NativeTimedCatchDifficultyAttributes* nativeTimedAttributesBuffer, int32_t* bufferSize)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        ManagedObjectHandle* modsHandle_instance;
        status = napi_unwrap(env, args[1], (void**) &modsHandle_instance);
        auto __arg1 = *modsHandle_instance;

        napi_valuetype __nativeTimedAttributesBuffer_type;
        status = napi_typeof(env, args[2], &__nativeTimedAttributesBuffer_type);
        assert(status == napi_ok);
        bool __nativeTimedAttributesBuffer_is_null = __nativeTimedAttributesBuffer_type == napi_null;

        int32_t* __nativeTimedAttributesBuffer_bufferSize_ptr = nullptr;
        int32_t __nativeTimedAttributesBuffer_buffer_count = 0;
        std::vector<NativeTimedCatchDifficultyAttributes> __nativeTimedAttributesBuffer_buffer;

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            napi_typedarray_type __nativeTimedAttributesBuffer_bufferSize_typedarray_type;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_length;
            void* __nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            napi_value __nativeTimedAttributesBuffer_bufferSize_typedarray_buffer;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_offset;
            status = napi_get_typedarray_info(env, args[3], &__nativeTimedAttributesBuffer_bufferSize_typedarray_type, &__nativeTimedAttributesBuffer_bufferSize_typedarray_length, &__nativeTimedAttributesBuffer_bufferSize_typedarray_data, &__nativeTimedAttributesBuffer_bufferSize_typedarray_buffer, &__nativeTimedAttributesBuffer_bufferSize_typedarray_offset);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_type == napi_int32_array);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_length >= 1);
            __nativeTimedAttributesBuffer_bufferSize_ptr = (int32_t*)__nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            __nativeTimedAttributesBuffer_buffer_count = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            assert(__nativeTimedAttributesBuffer_buffer_count >= 0);

            bool __nativeTimedAttributesBuffer_is_array = false;
            status = napi_is_array(env, args[2], &__nativeTimedAttributesBuffer_is_array);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_is_array);

            __nativeTimedAttributesBuffer_buffer.resize((size_t)__nativeTimedAttributesBuffer_buffer_count);
        }

        auto __arg2 = (NativeTimedCatchDifficultyAttributes*)(__nativeTimedAttributesBuffer_is_null || __nativeTimedAttributesBuffer_buffer_count == 0 ? nullptr : __nativeTimedAttributesBuffer_buffer.data());

        napi_typedarray_type __bufferSize_typedarray_type;
        size_t __bufferSize_typedarray_length;
        void* __bufferSize_typedarray_data;
        napi_value __bufferSize_typedarray_buffer;
        size_t __bufferSize_typedarray_offset;
        status = napi_get_typedarray_info(env, args[3], &__bufferSize_typedarray_type, &__bufferSize_typedarray_length, &__bufferSize_typedarray_data, &__bufferSize_typedarray_buffer, &__bufferSize_typedarray_offset);
        assert(status == napi_ok);
        assert(__bufferSize_typedarray_type == napi_int32_array);
        assert(__bufferSize_typedarray_length >= 1);
        int32_t* __arg3 = (int32_t*)__bufferSize_typedarray_data;
        ErrorCode ___ret = ::CatchDifficultyCalculator_CalculateModsTimed(__arg0, __arg1, __arg2, __arg3);

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            int32_t __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            if (__nativeTimedAttributesBuffer_written < 0) __nativeTimedAttributesBuffer_written = 0;
            if (__nativeTimedAttributesBuffer_written > __nativeTimedAttributesBuffer_buffer_count) __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_buffer_count;

            napi_value __nativeTimedAttributesBuffer_ctor;
            status = napi_get_reference_value(env, ctor_NativeTimedCatchDifficultyAttributes_NativeTimedCatchDifficultyAttributes, &__nativeTimedAttributesBuffer_ctor);
            assert(status == napi_ok);

            for (int32_t i = 0; i < __nativeTimedAttributesBuffer_written; i++)
            {
                napi_value __nativeTimedAttributesBuffer_instance;
                status = napi_new_instance(env, __nativeTimedAttributesBuffer_ctor, 0, nullptr, &__nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
                NativeTimedCatchDifficultyAttributes* __nativeTimedAttributesBuffer_native;
                status = napi_unwrap(env, __nativeTimedAttributesBuffer_instance, (void**) &__nativeTimedAttributesBuffer_native);
                assert(status == napi_ok);
                *__nativeTimedAttributesBuffer_native = __nativeTimedAttributesBuffer_buffer[(size_t)i];
                status = napi_set_element(env, args[2], (uint32_t)i, __nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
            }
        }

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__CatchDifficultyCalculator_CalculateModsTimed(napi_env env)
{
    napi_status status;
    napi_value __CatchDifficultyCalculator_CalculateModsTimed;
    status = napi_create_function(env, "CatchDifficultyCalculator_CalculateModsTimed", NAPI_AUTO_LENGTH, callback_function__CatchDifficultyCalculator_CalculateModsTimed, 0, &__CatchDifficultyCalculator_CalculateModsTimed);
    assert(status == napi_ok);

    return __CatchDifficultyCalculator_CalculateModsTimed;
}

// CatchDifficultyCalculator_Destroy
static napi_value callback_function__CatchDifficultyCalculator_Destroy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode CatchDifficultyCalculator_Destroy(ManagedObjectHandle handle)
overload0:
    {
        ManagedObjectHandle* handle_instance;
        status = napi_unwrap(env, args[0], (void**) &handle_instance);
        auto __arg0 = *handle_instance;

        ErrorCode ___ret = ::CatchDifficultyCalculator_Destroy(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__CatchDifficultyCalculator_Destroy(napi_env env)
{
    napi_status status;
    napi_value __CatchDifficultyCalculator_Destroy;
    status = napi_create_function(env, "CatchDifficultyCalculator_Destroy", NAPI_AUTO_LENGTH, callback_function__CatchDifficultyCalculator_Destroy, 0, &__CatchDifficultyCalculator_Destroy);
    assert(status == napi_ok);

    return __CatchDifficultyCalculator_Destroy;
}

// ManiaDifficultyCalculator_Create
static napi_value callback_function__ManiaDifficultyCalculator_Create(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode ManiaDifficultyCalculator_Create(ManagedObjectHandle rulesetHandle, ManagedObjectHandle beatmapHandle, NativeManiaDifficultyCalculator* nativeManiaDifficultyCalculatorPtr)
overload0:
    {
        ManagedObjectHandle* rulesetHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &rulesetHandle_instance);
        auto __arg0 = *rulesetHandle_instance;

        ManagedObjectHandle* beatmapHandle_instance;
        status = napi_unwrap(env, args[1], (void**) &beatmapHandle_instance);
        auto __arg1 = *beatmapHandle_instance;

        NativeManiaDifficultyCalculator* nativeManiaDifficultyCalculatorPtr_instance;
        status = napi_unwrap(env, args[2], (void**) &nativeManiaDifficultyCalculatorPtr_instance);
        auto __arg2 = nativeManiaDifficultyCalculatorPtr_instance;

        ErrorCode ___ret = ::ManiaDifficultyCalculator_Create(__arg0, __arg1, __arg2);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__ManiaDifficultyCalculator_Create(napi_env env)
{
    napi_status status;
    napi_value __ManiaDifficultyCalculator_Create;
    status = napi_create_function(env, "ManiaDifficultyCalculator_Create", NAPI_AUTO_LENGTH, callback_function__ManiaDifficultyCalculator_Create, 0, &__ManiaDifficultyCalculator_Create);
    assert(status == napi_ok);

    return __ManiaDifficultyCalculator_Create;
}

// ManiaDifficultyCalculator_Calculate
static napi_value callback_function__ManiaDifficultyCalculator_Calculate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode ManiaDifficultyCalculator_Calculate(ManagedObjectHandle calcHandle, NativeManiaDifficultyAttributes* nativeAttributesPtr)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        NativeManiaDifficultyAttributes* nativeAttributesPtr_instance;
        status = napi_unwrap(env, args[1], (void**) &nativeAttributesPtr_instance);
        auto __arg1 = nativeAttributesPtr_instance;

        ErrorCode ___ret = ::ManiaDifficultyCalculator_Calculate(__arg0, __arg1);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__ManiaDifficultyCalculator_Calculate(napi_env env)
{
    napi_status status;
    napi_value __ManiaDifficultyCalculator_Calculate;
    status = napi_create_function(env, "ManiaDifficultyCalculator_Calculate", NAPI_AUTO_LENGTH, callback_function__ManiaDifficultyCalculator_Calculate, 0, &__ManiaDifficultyCalculator_Calculate);
    assert(status == napi_ok);

    return __ManiaDifficultyCalculator_Calculate;
}

// ManiaDifficultyCalculator_CalculateMods
static napi_value callback_function__ManiaDifficultyCalculator_CalculateMods(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode ManiaDifficultyCalculator_CalculateMods(ManagedObjectHandle calcHandle, ManagedObjectHandle modsHandle, NativeManiaDifficultyAttributes* nativeAttributesPtr)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        ManagedObjectHandle* modsHandle_instance;
        status = napi_unwrap(env, args[1], (void**) &modsHandle_instance);
        auto __arg1 = *modsHandle_instance;

        NativeManiaDifficultyAttributes* nativeAttributesPtr_instance;
        status = napi_unwrap(env, args[2], (void**) &nativeAttributesPtr_instance);
        auto __arg2 = nativeAttributesPtr_instance;

        ErrorCode ___ret = ::ManiaDifficultyCalculator_CalculateMods(__arg0, __arg1, __arg2);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__ManiaDifficultyCalculator_CalculateMods(napi_env env)
{
    napi_status status;
    napi_value __ManiaDifficultyCalculator_CalculateMods;
    status = napi_create_function(env, "ManiaDifficultyCalculator_CalculateMods", NAPI_AUTO_LENGTH, callback_function__ManiaDifficultyCalculator_CalculateMods, 0, &__ManiaDifficultyCalculator_CalculateMods);
    assert(status == napi_ok);

    return __ManiaDifficultyCalculator_CalculateMods;
}

// ManiaDifficultyCalculator_CalculateTimed
static napi_value callback_function__ManiaDifficultyCalculator_CalculateTimed(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_NULL(types[1]) || NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode ManiaDifficultyCalculator_CalculateTimed(ManagedObjectHandle calcHandle, NativeTimedManiaDifficultyAttributes* nativeTimedAttributesBuffer, int32_t* bufferSize)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        napi_valuetype __nativeTimedAttributesBuffer_type;
        status = napi_typeof(env, args[1], &__nativeTimedAttributesBuffer_type);
        assert(status == napi_ok);
        bool __nativeTimedAttributesBuffer_is_null = __nativeTimedAttributesBuffer_type == napi_null;

        int32_t* __nativeTimedAttributesBuffer_bufferSize_ptr = nullptr;
        int32_t __nativeTimedAttributesBuffer_buffer_count = 0;
        std::vector<NativeTimedManiaDifficultyAttributes> __nativeTimedAttributesBuffer_buffer;

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            napi_typedarray_type __nativeTimedAttributesBuffer_bufferSize_typedarray_type;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_length;
            void* __nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            napi_value __nativeTimedAttributesBuffer_bufferSize_typedarray_buffer;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_offset;
            status = napi_get_typedarray_info(env, args[2], &__nativeTimedAttributesBuffer_bufferSize_typedarray_type, &__nativeTimedAttributesBuffer_bufferSize_typedarray_length, &__nativeTimedAttributesBuffer_bufferSize_typedarray_data, &__nativeTimedAttributesBuffer_bufferSize_typedarray_buffer, &__nativeTimedAttributesBuffer_bufferSize_typedarray_offset);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_type == napi_int32_array);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_length >= 1);
            __nativeTimedAttributesBuffer_bufferSize_ptr = (int32_t*)__nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            __nativeTimedAttributesBuffer_buffer_count = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            assert(__nativeTimedAttributesBuffer_buffer_count >= 0);

            bool __nativeTimedAttributesBuffer_is_array = false;
            status = napi_is_array(env, args[1], &__nativeTimedAttributesBuffer_is_array);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_is_array);

            __nativeTimedAttributesBuffer_buffer.resize((size_t)__nativeTimedAttributesBuffer_buffer_count);
        }

        auto __arg1 = (NativeTimedManiaDifficultyAttributes*)(__nativeTimedAttributesBuffer_is_null || __nativeTimedAttributesBuffer_buffer_count == 0 ? nullptr : __nativeTimedAttributesBuffer_buffer.data());

        napi_typedarray_type __bufferSize_typedarray_type;
        size_t __bufferSize_typedarray_length;
        void* __bufferSize_typedarray_data;
        napi_value __bufferSize_typedarray_buffer;
        size_t __bufferSize_typedarray_offset;
        status = napi_get_typedarray_info(env, args[2], &__bufferSize_typedarray_type, &__bufferSize_typedarray_length, &__bufferSize_typedarray_data, &__bufferSize_typedarray_buffer, &__bufferSize_typedarray_offset);
        assert(status == napi_ok);
        assert(__bufferSize_typedarray_type == napi_int32_array);
        assert(__bufferSize_typedarray_length >= 1);
        int32_t* __arg2 = (int32_t*)__bufferSize_typedarray_data;
        ErrorCode ___ret = ::ManiaDifficultyCalculator_CalculateTimed(__arg0, __arg1, __arg2);

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            int32_t __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            if (__nativeTimedAttributesBuffer_written < 0) __nativeTimedAttributesBuffer_written = 0;
            if (__nativeTimedAttributesBuffer_written > __nativeTimedAttributesBuffer_buffer_count) __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_buffer_count;

            napi_value __nativeTimedAttributesBuffer_ctor;
            status = napi_get_reference_value(env, ctor_NativeTimedManiaDifficultyAttributes_NativeTimedManiaDifficultyAttributes, &__nativeTimedAttributesBuffer_ctor);
            assert(status == napi_ok);

            for (int32_t i = 0; i < __nativeTimedAttributesBuffer_written; i++)
            {
                napi_value __nativeTimedAttributesBuffer_instance;
                status = napi_new_instance(env, __nativeTimedAttributesBuffer_ctor, 0, nullptr, &__nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
                NativeTimedManiaDifficultyAttributes* __nativeTimedAttributesBuffer_native;
                status = napi_unwrap(env, __nativeTimedAttributesBuffer_instance, (void**) &__nativeTimedAttributesBuffer_native);
                assert(status == napi_ok);
                *__nativeTimedAttributesBuffer_native = __nativeTimedAttributesBuffer_buffer[(size_t)i];
                status = napi_set_element(env, args[1], (uint32_t)i, __nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
            }
        }

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__ManiaDifficultyCalculator_CalculateTimed(napi_env env)
{
    napi_status status;
    napi_value __ManiaDifficultyCalculator_CalculateTimed;
    status = napi_create_function(env, "ManiaDifficultyCalculator_CalculateTimed", NAPI_AUTO_LENGTH, callback_function__ManiaDifficultyCalculator_CalculateTimed, 0, &__ManiaDifficultyCalculator_CalculateTimed);
    assert(status == napi_ok);

    return __ManiaDifficultyCalculator_CalculateTimed;
}

// ManiaDifficultyCalculator_CalculateModsTimed
static napi_value callback_function__ManiaDifficultyCalculator_CalculateModsTimed(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 4 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_NULL(types[2]) || NAPI_IS_OBJECT(types[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_OBJECT(types[3]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode ManiaDifficultyCalculator_CalculateModsTimed(ManagedObjectHandle calcHandle, ManagedObjectHandle modsHandle, NativeTimedManiaDifficultyAttributes* nativeTimedAttributesBuffer, int32_t* bufferSize)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        ManagedObjectHandle* modsHandle_instance;
        status = napi_unwrap(env, args[1], (void**) &modsHandle_instance);
        auto __arg1 = *modsHandle_instance;

        napi_valuetype __nativeTimedAttributesBuffer_type;
        status = napi_typeof(env, args[2], &__nativeTimedAttributesBuffer_type);
        assert(status == napi_ok);
        bool __nativeTimedAttributesBuffer_is_null = __nativeTimedAttributesBuffer_type == napi_null;

        int32_t* __nativeTimedAttributesBuffer_bufferSize_ptr = nullptr;
        int32_t __nativeTimedAttributesBuffer_buffer_count = 0;
        std::vector<NativeTimedManiaDifficultyAttributes> __nativeTimedAttributesBuffer_buffer;

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            napi_typedarray_type __nativeTimedAttributesBuffer_bufferSize_typedarray_type;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_length;
            void* __nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            napi_value __nativeTimedAttributesBuffer_bufferSize_typedarray_buffer;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_offset;
            status = napi_get_typedarray_info(env, args[3], &__nativeTimedAttributesBuffer_bufferSize_typedarray_type, &__nativeTimedAttributesBuffer_bufferSize_typedarray_length, &__nativeTimedAttributesBuffer_bufferSize_typedarray_data, &__nativeTimedAttributesBuffer_bufferSize_typedarray_buffer, &__nativeTimedAttributesBuffer_bufferSize_typedarray_offset);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_type == napi_int32_array);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_length >= 1);
            __nativeTimedAttributesBuffer_bufferSize_ptr = (int32_t*)__nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            __nativeTimedAttributesBuffer_buffer_count = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            assert(__nativeTimedAttributesBuffer_buffer_count >= 0);

            bool __nativeTimedAttributesBuffer_is_array = false;
            status = napi_is_array(env, args[2], &__nativeTimedAttributesBuffer_is_array);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_is_array);

            __nativeTimedAttributesBuffer_buffer.resize((size_t)__nativeTimedAttributesBuffer_buffer_count);
        }

        auto __arg2 = (NativeTimedManiaDifficultyAttributes*)(__nativeTimedAttributesBuffer_is_null || __nativeTimedAttributesBuffer_buffer_count == 0 ? nullptr : __nativeTimedAttributesBuffer_buffer.data());

        napi_typedarray_type __bufferSize_typedarray_type;
        size_t __bufferSize_typedarray_length;
        void* __bufferSize_typedarray_data;
        napi_value __bufferSize_typedarray_buffer;
        size_t __bufferSize_typedarray_offset;
        status = napi_get_typedarray_info(env, args[3], &__bufferSize_typedarray_type, &__bufferSize_typedarray_length, &__bufferSize_typedarray_data, &__bufferSize_typedarray_buffer, &__bufferSize_typedarray_offset);
        assert(status == napi_ok);
        assert(__bufferSize_typedarray_type == napi_int32_array);
        assert(__bufferSize_typedarray_length >= 1);
        int32_t* __arg3 = (int32_t*)__bufferSize_typedarray_data;
        ErrorCode ___ret = ::ManiaDifficultyCalculator_CalculateModsTimed(__arg0, __arg1, __arg2, __arg3);

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            int32_t __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            if (__nativeTimedAttributesBuffer_written < 0) __nativeTimedAttributesBuffer_written = 0;
            if (__nativeTimedAttributesBuffer_written > __nativeTimedAttributesBuffer_buffer_count) __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_buffer_count;

            napi_value __nativeTimedAttributesBuffer_ctor;
            status = napi_get_reference_value(env, ctor_NativeTimedManiaDifficultyAttributes_NativeTimedManiaDifficultyAttributes, &__nativeTimedAttributesBuffer_ctor);
            assert(status == napi_ok);

            for (int32_t i = 0; i < __nativeTimedAttributesBuffer_written; i++)
            {
                napi_value __nativeTimedAttributesBuffer_instance;
                status = napi_new_instance(env, __nativeTimedAttributesBuffer_ctor, 0, nullptr, &__nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
                NativeTimedManiaDifficultyAttributes* __nativeTimedAttributesBuffer_native;
                status = napi_unwrap(env, __nativeTimedAttributesBuffer_instance, (void**) &__nativeTimedAttributesBuffer_native);
                assert(status == napi_ok);
                *__nativeTimedAttributesBuffer_native = __nativeTimedAttributesBuffer_buffer[(size_t)i];
                status = napi_set_element(env, args[2], (uint32_t)i, __nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
            }
        }

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__ManiaDifficultyCalculator_CalculateModsTimed(napi_env env)
{
    napi_status status;
    napi_value __ManiaDifficultyCalculator_CalculateModsTimed;
    status = napi_create_function(env, "ManiaDifficultyCalculator_CalculateModsTimed", NAPI_AUTO_LENGTH, callback_function__ManiaDifficultyCalculator_CalculateModsTimed, 0, &__ManiaDifficultyCalculator_CalculateModsTimed);
    assert(status == napi_ok);

    return __ManiaDifficultyCalculator_CalculateModsTimed;
}

// ManiaDifficultyCalculator_Destroy
static napi_value callback_function__ManiaDifficultyCalculator_Destroy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode ManiaDifficultyCalculator_Destroy(ManagedObjectHandle handle)
overload0:
    {
        ManagedObjectHandle* handle_instance;
        status = napi_unwrap(env, args[0], (void**) &handle_instance);
        auto __arg0 = *handle_instance;

        ErrorCode ___ret = ::ManiaDifficultyCalculator_Destroy(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__ManiaDifficultyCalculator_Destroy(napi_env env)
{
    napi_status status;
    napi_value __ManiaDifficultyCalculator_Destroy;
    status = napi_create_function(env, "ManiaDifficultyCalculator_Destroy", NAPI_AUTO_LENGTH, callback_function__ManiaDifficultyCalculator_Destroy, 0, &__ManiaDifficultyCalculator_Destroy);
    assert(status == napi_ok);

    return __ManiaDifficultyCalculator_Destroy;
}

// OsuDifficultyCalculator_Create
static napi_value callback_function__OsuDifficultyCalculator_Create(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode OsuDifficultyCalculator_Create(ManagedObjectHandle rulesetHandle, ManagedObjectHandle beatmapHandle, NativeOsuDifficultyCalculator* nativeOsuDifficultyCalculatorPtr)
overload0:
    {
        ManagedObjectHandle* rulesetHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &rulesetHandle_instance);
        auto __arg0 = *rulesetHandle_instance;

        ManagedObjectHandle* beatmapHandle_instance;
        status = napi_unwrap(env, args[1], (void**) &beatmapHandle_instance);
        auto __arg1 = *beatmapHandle_instance;

        NativeOsuDifficultyCalculator* nativeOsuDifficultyCalculatorPtr_instance;
        status = napi_unwrap(env, args[2], (void**) &nativeOsuDifficultyCalculatorPtr_instance);
        auto __arg2 = nativeOsuDifficultyCalculatorPtr_instance;

        ErrorCode ___ret = ::OsuDifficultyCalculator_Create(__arg0, __arg1, __arg2);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__OsuDifficultyCalculator_Create(napi_env env)
{
    napi_status status;
    napi_value __OsuDifficultyCalculator_Create;
    status = napi_create_function(env, "OsuDifficultyCalculator_Create", NAPI_AUTO_LENGTH, callback_function__OsuDifficultyCalculator_Create, 0, &__OsuDifficultyCalculator_Create);
    assert(status == napi_ok);

    return __OsuDifficultyCalculator_Create;
}

// OsuDifficultyCalculator_Calculate
static napi_value callback_function__OsuDifficultyCalculator_Calculate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode OsuDifficultyCalculator_Calculate(ManagedObjectHandle calcHandle, NativeOsuDifficultyAttributes* nativeAttributesPtr)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        NativeOsuDifficultyAttributes* nativeAttributesPtr_instance;
        status = napi_unwrap(env, args[1], (void**) &nativeAttributesPtr_instance);
        auto __arg1 = nativeAttributesPtr_instance;

        ErrorCode ___ret = ::OsuDifficultyCalculator_Calculate(__arg0, __arg1);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__OsuDifficultyCalculator_Calculate(napi_env env)
{
    napi_status status;
    napi_value __OsuDifficultyCalculator_Calculate;
    status = napi_create_function(env, "OsuDifficultyCalculator_Calculate", NAPI_AUTO_LENGTH, callback_function__OsuDifficultyCalculator_Calculate, 0, &__OsuDifficultyCalculator_Calculate);
    assert(status == napi_ok);

    return __OsuDifficultyCalculator_Calculate;
}

// OsuDifficultyCalculator_CalculateMods
static napi_value callback_function__OsuDifficultyCalculator_CalculateMods(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode OsuDifficultyCalculator_CalculateMods(ManagedObjectHandle calcHandle, ManagedObjectHandle modsHandle, NativeOsuDifficultyAttributes* nativeAttributesPtr)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        ManagedObjectHandle* modsHandle_instance;
        status = napi_unwrap(env, args[1], (void**) &modsHandle_instance);
        auto __arg1 = *modsHandle_instance;

        NativeOsuDifficultyAttributes* nativeAttributesPtr_instance;
        status = napi_unwrap(env, args[2], (void**) &nativeAttributesPtr_instance);
        auto __arg2 = nativeAttributesPtr_instance;

        ErrorCode ___ret = ::OsuDifficultyCalculator_CalculateMods(__arg0, __arg1, __arg2);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__OsuDifficultyCalculator_CalculateMods(napi_env env)
{
    napi_status status;
    napi_value __OsuDifficultyCalculator_CalculateMods;
    status = napi_create_function(env, "OsuDifficultyCalculator_CalculateMods", NAPI_AUTO_LENGTH, callback_function__OsuDifficultyCalculator_CalculateMods, 0, &__OsuDifficultyCalculator_CalculateMods);
    assert(status == napi_ok);

    return __OsuDifficultyCalculator_CalculateMods;
}

// OsuDifficultyCalculator_CalculateTimed
static napi_value callback_function__OsuDifficultyCalculator_CalculateTimed(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_NULL(types[1]) || NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode OsuDifficultyCalculator_CalculateTimed(ManagedObjectHandle calcHandle, NativeTimedOsuDifficultyAttributes* nativeTimedAttributesBuffer, int32_t* bufferSize)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        napi_valuetype __nativeTimedAttributesBuffer_type;
        status = napi_typeof(env, args[1], &__nativeTimedAttributesBuffer_type);
        assert(status == napi_ok);
        bool __nativeTimedAttributesBuffer_is_null = __nativeTimedAttributesBuffer_type == napi_null;

        int32_t* __nativeTimedAttributesBuffer_bufferSize_ptr = nullptr;
        int32_t __nativeTimedAttributesBuffer_buffer_count = 0;
        std::vector<NativeTimedOsuDifficultyAttributes> __nativeTimedAttributesBuffer_buffer;

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            napi_typedarray_type __nativeTimedAttributesBuffer_bufferSize_typedarray_type;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_length;
            void* __nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            napi_value __nativeTimedAttributesBuffer_bufferSize_typedarray_buffer;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_offset;
            status = napi_get_typedarray_info(env, args[2], &__nativeTimedAttributesBuffer_bufferSize_typedarray_type, &__nativeTimedAttributesBuffer_bufferSize_typedarray_length, &__nativeTimedAttributesBuffer_bufferSize_typedarray_data, &__nativeTimedAttributesBuffer_bufferSize_typedarray_buffer, &__nativeTimedAttributesBuffer_bufferSize_typedarray_offset);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_type == napi_int32_array);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_length >= 1);
            __nativeTimedAttributesBuffer_bufferSize_ptr = (int32_t*)__nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            __nativeTimedAttributesBuffer_buffer_count = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            assert(__nativeTimedAttributesBuffer_buffer_count >= 0);

            bool __nativeTimedAttributesBuffer_is_array = false;
            status = napi_is_array(env, args[1], &__nativeTimedAttributesBuffer_is_array);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_is_array);

            __nativeTimedAttributesBuffer_buffer.resize((size_t)__nativeTimedAttributesBuffer_buffer_count);
        }

        auto __arg1 = (NativeTimedOsuDifficultyAttributes*)(__nativeTimedAttributesBuffer_is_null || __nativeTimedAttributesBuffer_buffer_count == 0 ? nullptr : __nativeTimedAttributesBuffer_buffer.data());

        napi_typedarray_type __bufferSize_typedarray_type;
        size_t __bufferSize_typedarray_length;
        void* __bufferSize_typedarray_data;
        napi_value __bufferSize_typedarray_buffer;
        size_t __bufferSize_typedarray_offset;
        status = napi_get_typedarray_info(env, args[2], &__bufferSize_typedarray_type, &__bufferSize_typedarray_length, &__bufferSize_typedarray_data, &__bufferSize_typedarray_buffer, &__bufferSize_typedarray_offset);
        assert(status == napi_ok);
        assert(__bufferSize_typedarray_type == napi_int32_array);
        assert(__bufferSize_typedarray_length >= 1);
        int32_t* __arg2 = (int32_t*)__bufferSize_typedarray_data;
        ErrorCode ___ret = ::OsuDifficultyCalculator_CalculateTimed(__arg0, __arg1, __arg2);

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            int32_t __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            if (__nativeTimedAttributesBuffer_written < 0) __nativeTimedAttributesBuffer_written = 0;
            if (__nativeTimedAttributesBuffer_written > __nativeTimedAttributesBuffer_buffer_count) __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_buffer_count;

            napi_value __nativeTimedAttributesBuffer_ctor;
            status = napi_get_reference_value(env, ctor_NativeTimedOsuDifficultyAttributes_NativeTimedOsuDifficultyAttributes, &__nativeTimedAttributesBuffer_ctor);
            assert(status == napi_ok);

            for (int32_t i = 0; i < __nativeTimedAttributesBuffer_written; i++)
            {
                napi_value __nativeTimedAttributesBuffer_instance;
                status = napi_new_instance(env, __nativeTimedAttributesBuffer_ctor, 0, nullptr, &__nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
                NativeTimedOsuDifficultyAttributes* __nativeTimedAttributesBuffer_native;
                status = napi_unwrap(env, __nativeTimedAttributesBuffer_instance, (void**) &__nativeTimedAttributesBuffer_native);
                assert(status == napi_ok);
                *__nativeTimedAttributesBuffer_native = __nativeTimedAttributesBuffer_buffer[(size_t)i];
                status = napi_set_element(env, args[1], (uint32_t)i, __nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
            }
        }

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__OsuDifficultyCalculator_CalculateTimed(napi_env env)
{
    napi_status status;
    napi_value __OsuDifficultyCalculator_CalculateTimed;
    status = napi_create_function(env, "OsuDifficultyCalculator_CalculateTimed", NAPI_AUTO_LENGTH, callback_function__OsuDifficultyCalculator_CalculateTimed, 0, &__OsuDifficultyCalculator_CalculateTimed);
    assert(status == napi_ok);

    return __OsuDifficultyCalculator_CalculateTimed;
}

// OsuDifficultyCalculator_CalculateModsTimed
static napi_value callback_function__OsuDifficultyCalculator_CalculateModsTimed(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 4 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_NULL(types[2]) || NAPI_IS_OBJECT(types[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_OBJECT(types[3]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode OsuDifficultyCalculator_CalculateModsTimed(ManagedObjectHandle calcHandle, ManagedObjectHandle modsHandle, NativeTimedOsuDifficultyAttributes* nativeTimedAttributesBuffer, int32_t* bufferSize)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        ManagedObjectHandle* modsHandle_instance;
        status = napi_unwrap(env, args[1], (void**) &modsHandle_instance);
        auto __arg1 = *modsHandle_instance;

        napi_valuetype __nativeTimedAttributesBuffer_type;
        status = napi_typeof(env, args[2], &__nativeTimedAttributesBuffer_type);
        assert(status == napi_ok);
        bool __nativeTimedAttributesBuffer_is_null = __nativeTimedAttributesBuffer_type == napi_null;

        int32_t* __nativeTimedAttributesBuffer_bufferSize_ptr = nullptr;
        int32_t __nativeTimedAttributesBuffer_buffer_count = 0;
        std::vector<NativeTimedOsuDifficultyAttributes> __nativeTimedAttributesBuffer_buffer;

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            napi_typedarray_type __nativeTimedAttributesBuffer_bufferSize_typedarray_type;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_length;
            void* __nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            napi_value __nativeTimedAttributesBuffer_bufferSize_typedarray_buffer;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_offset;
            status = napi_get_typedarray_info(env, args[3], &__nativeTimedAttributesBuffer_bufferSize_typedarray_type, &__nativeTimedAttributesBuffer_bufferSize_typedarray_length, &__nativeTimedAttributesBuffer_bufferSize_typedarray_data, &__nativeTimedAttributesBuffer_bufferSize_typedarray_buffer, &__nativeTimedAttributesBuffer_bufferSize_typedarray_offset);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_type == napi_int32_array);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_length >= 1);
            __nativeTimedAttributesBuffer_bufferSize_ptr = (int32_t*)__nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            __nativeTimedAttributesBuffer_buffer_count = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            assert(__nativeTimedAttributesBuffer_buffer_count >= 0);

            bool __nativeTimedAttributesBuffer_is_array = false;
            status = napi_is_array(env, args[2], &__nativeTimedAttributesBuffer_is_array);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_is_array);

            __nativeTimedAttributesBuffer_buffer.resize((size_t)__nativeTimedAttributesBuffer_buffer_count);
        }

        auto __arg2 = (NativeTimedOsuDifficultyAttributes*)(__nativeTimedAttributesBuffer_is_null || __nativeTimedAttributesBuffer_buffer_count == 0 ? nullptr : __nativeTimedAttributesBuffer_buffer.data());

        napi_typedarray_type __bufferSize_typedarray_type;
        size_t __bufferSize_typedarray_length;
        void* __bufferSize_typedarray_data;
        napi_value __bufferSize_typedarray_buffer;
        size_t __bufferSize_typedarray_offset;
        status = napi_get_typedarray_info(env, args[3], &__bufferSize_typedarray_type, &__bufferSize_typedarray_length, &__bufferSize_typedarray_data, &__bufferSize_typedarray_buffer, &__bufferSize_typedarray_offset);
        assert(status == napi_ok);
        assert(__bufferSize_typedarray_type == napi_int32_array);
        assert(__bufferSize_typedarray_length >= 1);
        int32_t* __arg3 = (int32_t*)__bufferSize_typedarray_data;
        ErrorCode ___ret = ::OsuDifficultyCalculator_CalculateModsTimed(__arg0, __arg1, __arg2, __arg3);

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            int32_t __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            if (__nativeTimedAttributesBuffer_written < 0) __nativeTimedAttributesBuffer_written = 0;
            if (__nativeTimedAttributesBuffer_written > __nativeTimedAttributesBuffer_buffer_count) __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_buffer_count;

            napi_value __nativeTimedAttributesBuffer_ctor;
            status = napi_get_reference_value(env, ctor_NativeTimedOsuDifficultyAttributes_NativeTimedOsuDifficultyAttributes, &__nativeTimedAttributesBuffer_ctor);
            assert(status == napi_ok);

            for (int32_t i = 0; i < __nativeTimedAttributesBuffer_written; i++)
            {
                napi_value __nativeTimedAttributesBuffer_instance;
                status = napi_new_instance(env, __nativeTimedAttributesBuffer_ctor, 0, nullptr, &__nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
                NativeTimedOsuDifficultyAttributes* __nativeTimedAttributesBuffer_native;
                status = napi_unwrap(env, __nativeTimedAttributesBuffer_instance, (void**) &__nativeTimedAttributesBuffer_native);
                assert(status == napi_ok);
                *__nativeTimedAttributesBuffer_native = __nativeTimedAttributesBuffer_buffer[(size_t)i];
                status = napi_set_element(env, args[2], (uint32_t)i, __nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
            }
        }

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__OsuDifficultyCalculator_CalculateModsTimed(napi_env env)
{
    napi_status status;
    napi_value __OsuDifficultyCalculator_CalculateModsTimed;
    status = napi_create_function(env, "OsuDifficultyCalculator_CalculateModsTimed", NAPI_AUTO_LENGTH, callback_function__OsuDifficultyCalculator_CalculateModsTimed, 0, &__OsuDifficultyCalculator_CalculateModsTimed);
    assert(status == napi_ok);

    return __OsuDifficultyCalculator_CalculateModsTimed;
}

// OsuDifficultyCalculator_Destroy
static napi_value callback_function__OsuDifficultyCalculator_Destroy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode OsuDifficultyCalculator_Destroy(ManagedObjectHandle handle)
overload0:
    {
        ManagedObjectHandle* handle_instance;
        status = napi_unwrap(env, args[0], (void**) &handle_instance);
        auto __arg0 = *handle_instance;

        ErrorCode ___ret = ::OsuDifficultyCalculator_Destroy(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__OsuDifficultyCalculator_Destroy(napi_env env)
{
    napi_status status;
    napi_value __OsuDifficultyCalculator_Destroy;
    status = napi_create_function(env, "OsuDifficultyCalculator_Destroy", NAPI_AUTO_LENGTH, callback_function__OsuDifficultyCalculator_Destroy, 0, &__OsuDifficultyCalculator_Destroy);
    assert(status == napi_ok);

    return __OsuDifficultyCalculator_Destroy;
}

// TaikoDifficultyCalculator_Create
static napi_value callback_function__TaikoDifficultyCalculator_Create(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode TaikoDifficultyCalculator_Create(ManagedObjectHandle rulesetHandle, ManagedObjectHandle beatmapHandle, NativeTaikoDifficultyCalculator* nativeTaikoDifficultyCalculatorPtr)
overload0:
    {
        ManagedObjectHandle* rulesetHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &rulesetHandle_instance);
        auto __arg0 = *rulesetHandle_instance;

        ManagedObjectHandle* beatmapHandle_instance;
        status = napi_unwrap(env, args[1], (void**) &beatmapHandle_instance);
        auto __arg1 = *beatmapHandle_instance;

        NativeTaikoDifficultyCalculator* nativeTaikoDifficultyCalculatorPtr_instance;
        status = napi_unwrap(env, args[2], (void**) &nativeTaikoDifficultyCalculatorPtr_instance);
        auto __arg2 = nativeTaikoDifficultyCalculatorPtr_instance;

        ErrorCode ___ret = ::TaikoDifficultyCalculator_Create(__arg0, __arg1, __arg2);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__TaikoDifficultyCalculator_Create(napi_env env)
{
    napi_status status;
    napi_value __TaikoDifficultyCalculator_Create;
    status = napi_create_function(env, "TaikoDifficultyCalculator_Create", NAPI_AUTO_LENGTH, callback_function__TaikoDifficultyCalculator_Create, 0, &__TaikoDifficultyCalculator_Create);
    assert(status == napi_ok);

    return __TaikoDifficultyCalculator_Create;
}

// TaikoDifficultyCalculator_Calculate
static napi_value callback_function__TaikoDifficultyCalculator_Calculate(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 2 || argc > 2)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode TaikoDifficultyCalculator_Calculate(ManagedObjectHandle calcHandle, NativeTaikoDifficultyAttributes* nativeAttributesPtr)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        NativeTaikoDifficultyAttributes* nativeAttributesPtr_instance;
        status = napi_unwrap(env, args[1], (void**) &nativeAttributesPtr_instance);
        auto __arg1 = nativeAttributesPtr_instance;

        ErrorCode ___ret = ::TaikoDifficultyCalculator_Calculate(__arg0, __arg1);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__TaikoDifficultyCalculator_Calculate(napi_env env)
{
    napi_status status;
    napi_value __TaikoDifficultyCalculator_Calculate;
    status = napi_create_function(env, "TaikoDifficultyCalculator_Calculate", NAPI_AUTO_LENGTH, callback_function__TaikoDifficultyCalculator_Calculate, 0, &__TaikoDifficultyCalculator_Calculate);
    assert(status == napi_ok);

    return __TaikoDifficultyCalculator_Calculate;
}

// TaikoDifficultyCalculator_CalculateMods
static napi_value callback_function__TaikoDifficultyCalculator_CalculateMods(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode TaikoDifficultyCalculator_CalculateMods(ManagedObjectHandle calcHandle, ManagedObjectHandle modsHandle, NativeTaikoDifficultyAttributes* nativeAttributesPtr)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        ManagedObjectHandle* modsHandle_instance;
        status = napi_unwrap(env, args[1], (void**) &modsHandle_instance);
        auto __arg1 = *modsHandle_instance;

        NativeTaikoDifficultyAttributes* nativeAttributesPtr_instance;
        status = napi_unwrap(env, args[2], (void**) &nativeAttributesPtr_instance);
        auto __arg2 = nativeAttributesPtr_instance;

        ErrorCode ___ret = ::TaikoDifficultyCalculator_CalculateMods(__arg0, __arg1, __arg2);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__TaikoDifficultyCalculator_CalculateMods(napi_env env)
{
    napi_status status;
    napi_value __TaikoDifficultyCalculator_CalculateMods;
    status = napi_create_function(env, "TaikoDifficultyCalculator_CalculateMods", NAPI_AUTO_LENGTH, callback_function__TaikoDifficultyCalculator_CalculateMods, 0, &__TaikoDifficultyCalculator_CalculateMods);
    assert(status == napi_ok);

    return __TaikoDifficultyCalculator_CalculateMods;
}

// TaikoDifficultyCalculator_CalculateTimed
static napi_value callback_function__TaikoDifficultyCalculator_CalculateTimed(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 3 || argc > 3)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_NULL(types[1]) || NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_OBJECT(types[2]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode TaikoDifficultyCalculator_CalculateTimed(ManagedObjectHandle calcHandle, NativeTimedTaikoDifficultyAttributes* nativeTimedAttributesBuffer, int32_t* bufferSize)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        napi_valuetype __nativeTimedAttributesBuffer_type;
        status = napi_typeof(env, args[1], &__nativeTimedAttributesBuffer_type);
        assert(status == napi_ok);
        bool __nativeTimedAttributesBuffer_is_null = __nativeTimedAttributesBuffer_type == napi_null;

        int32_t* __nativeTimedAttributesBuffer_bufferSize_ptr = nullptr;
        int32_t __nativeTimedAttributesBuffer_buffer_count = 0;
        std::vector<NativeTimedTaikoDifficultyAttributes> __nativeTimedAttributesBuffer_buffer;

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            napi_typedarray_type __nativeTimedAttributesBuffer_bufferSize_typedarray_type;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_length;
            void* __nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            napi_value __nativeTimedAttributesBuffer_bufferSize_typedarray_buffer;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_offset;
            status = napi_get_typedarray_info(env, args[2], &__nativeTimedAttributesBuffer_bufferSize_typedarray_type, &__nativeTimedAttributesBuffer_bufferSize_typedarray_length, &__nativeTimedAttributesBuffer_bufferSize_typedarray_data, &__nativeTimedAttributesBuffer_bufferSize_typedarray_buffer, &__nativeTimedAttributesBuffer_bufferSize_typedarray_offset);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_type == napi_int32_array);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_length >= 1);
            __nativeTimedAttributesBuffer_bufferSize_ptr = (int32_t*)__nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            __nativeTimedAttributesBuffer_buffer_count = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            assert(__nativeTimedAttributesBuffer_buffer_count >= 0);

            bool __nativeTimedAttributesBuffer_is_array = false;
            status = napi_is_array(env, args[1], &__nativeTimedAttributesBuffer_is_array);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_is_array);

            __nativeTimedAttributesBuffer_buffer.resize((size_t)__nativeTimedAttributesBuffer_buffer_count);
        }

        auto __arg1 = (NativeTimedTaikoDifficultyAttributes*)(__nativeTimedAttributesBuffer_is_null || __nativeTimedAttributesBuffer_buffer_count == 0 ? nullptr : __nativeTimedAttributesBuffer_buffer.data());

        napi_typedarray_type __bufferSize_typedarray_type;
        size_t __bufferSize_typedarray_length;
        void* __bufferSize_typedarray_data;
        napi_value __bufferSize_typedarray_buffer;
        size_t __bufferSize_typedarray_offset;
        status = napi_get_typedarray_info(env, args[2], &__bufferSize_typedarray_type, &__bufferSize_typedarray_length, &__bufferSize_typedarray_data, &__bufferSize_typedarray_buffer, &__bufferSize_typedarray_offset);
        assert(status == napi_ok);
        assert(__bufferSize_typedarray_type == napi_int32_array);
        assert(__bufferSize_typedarray_length >= 1);
        int32_t* __arg2 = (int32_t*)__bufferSize_typedarray_data;
        ErrorCode ___ret = ::TaikoDifficultyCalculator_CalculateTimed(__arg0, __arg1, __arg2);

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            int32_t __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            if (__nativeTimedAttributesBuffer_written < 0) __nativeTimedAttributesBuffer_written = 0;
            if (__nativeTimedAttributesBuffer_written > __nativeTimedAttributesBuffer_buffer_count) __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_buffer_count;

            napi_value __nativeTimedAttributesBuffer_ctor;
            status = napi_get_reference_value(env, ctor_NativeTimedTaikoDifficultyAttributes_NativeTimedTaikoDifficultyAttributes, &__nativeTimedAttributesBuffer_ctor);
            assert(status == napi_ok);

            for (int32_t i = 0; i < __nativeTimedAttributesBuffer_written; i++)
            {
                napi_value __nativeTimedAttributesBuffer_instance;
                status = napi_new_instance(env, __nativeTimedAttributesBuffer_ctor, 0, nullptr, &__nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
                NativeTimedTaikoDifficultyAttributes* __nativeTimedAttributesBuffer_native;
                status = napi_unwrap(env, __nativeTimedAttributesBuffer_instance, (void**) &__nativeTimedAttributesBuffer_native);
                assert(status == napi_ok);
                *__nativeTimedAttributesBuffer_native = __nativeTimedAttributesBuffer_buffer[(size_t)i];
                status = napi_set_element(env, args[1], (uint32_t)i, __nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
            }
        }

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__TaikoDifficultyCalculator_CalculateTimed(napi_env env)
{
    napi_status status;
    napi_value __TaikoDifficultyCalculator_CalculateTimed;
    status = napi_create_function(env, "TaikoDifficultyCalculator_CalculateTimed", NAPI_AUTO_LENGTH, callback_function__TaikoDifficultyCalculator_CalculateTimed, 0, &__TaikoDifficultyCalculator_CalculateTimed);
    assert(status == napi_ok);

    return __TaikoDifficultyCalculator_CalculateTimed;
}

// TaikoDifficultyCalculator_CalculateModsTimed
static napi_value callback_function__TaikoDifficultyCalculator_CalculateModsTimed(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 4 || argc > 4)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto typecheck1;

    goto error;

typecheck1:
    if (NAPI_IS_OBJECT(types[1]))
        goto typecheck2;

    goto error;

typecheck2:
    if (NAPI_IS_NULL(types[2]) || NAPI_IS_OBJECT(types[2]))
        goto typecheck3;

    goto error;

typecheck3:
    if (NAPI_IS_OBJECT(types[3]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode TaikoDifficultyCalculator_CalculateModsTimed(ManagedObjectHandle calcHandle, ManagedObjectHandle modsHandle, NativeTimedTaikoDifficultyAttributes* nativeTimedAttributesBuffer, int32_t* bufferSize)
overload0:
    {
        ManagedObjectHandle* calcHandle_instance;
        status = napi_unwrap(env, args[0], (void**) &calcHandle_instance);
        auto __arg0 = *calcHandle_instance;

        ManagedObjectHandle* modsHandle_instance;
        status = napi_unwrap(env, args[1], (void**) &modsHandle_instance);
        auto __arg1 = *modsHandle_instance;

        napi_valuetype __nativeTimedAttributesBuffer_type;
        status = napi_typeof(env, args[2], &__nativeTimedAttributesBuffer_type);
        assert(status == napi_ok);
        bool __nativeTimedAttributesBuffer_is_null = __nativeTimedAttributesBuffer_type == napi_null;

        int32_t* __nativeTimedAttributesBuffer_bufferSize_ptr = nullptr;
        int32_t __nativeTimedAttributesBuffer_buffer_count = 0;
        std::vector<NativeTimedTaikoDifficultyAttributes> __nativeTimedAttributesBuffer_buffer;

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            napi_typedarray_type __nativeTimedAttributesBuffer_bufferSize_typedarray_type;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_length;
            void* __nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            napi_value __nativeTimedAttributesBuffer_bufferSize_typedarray_buffer;
            size_t __nativeTimedAttributesBuffer_bufferSize_typedarray_offset;
            status = napi_get_typedarray_info(env, args[3], &__nativeTimedAttributesBuffer_bufferSize_typedarray_type, &__nativeTimedAttributesBuffer_bufferSize_typedarray_length, &__nativeTimedAttributesBuffer_bufferSize_typedarray_data, &__nativeTimedAttributesBuffer_bufferSize_typedarray_buffer, &__nativeTimedAttributesBuffer_bufferSize_typedarray_offset);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_type == napi_int32_array);
            assert(__nativeTimedAttributesBuffer_bufferSize_typedarray_length >= 1);
            __nativeTimedAttributesBuffer_bufferSize_ptr = (int32_t*)__nativeTimedAttributesBuffer_bufferSize_typedarray_data;
            __nativeTimedAttributesBuffer_buffer_count = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            assert(__nativeTimedAttributesBuffer_buffer_count >= 0);

            bool __nativeTimedAttributesBuffer_is_array = false;
            status = napi_is_array(env, args[2], &__nativeTimedAttributesBuffer_is_array);
            assert(status == napi_ok);
            assert(__nativeTimedAttributesBuffer_is_array);

            __nativeTimedAttributesBuffer_buffer.resize((size_t)__nativeTimedAttributesBuffer_buffer_count);
        }

        auto __arg2 = (NativeTimedTaikoDifficultyAttributes*)(__nativeTimedAttributesBuffer_is_null || __nativeTimedAttributesBuffer_buffer_count == 0 ? nullptr : __nativeTimedAttributesBuffer_buffer.data());

        napi_typedarray_type __bufferSize_typedarray_type;
        size_t __bufferSize_typedarray_length;
        void* __bufferSize_typedarray_data;
        napi_value __bufferSize_typedarray_buffer;
        size_t __bufferSize_typedarray_offset;
        status = napi_get_typedarray_info(env, args[3], &__bufferSize_typedarray_type, &__bufferSize_typedarray_length, &__bufferSize_typedarray_data, &__bufferSize_typedarray_buffer, &__bufferSize_typedarray_offset);
        assert(status == napi_ok);
        assert(__bufferSize_typedarray_type == napi_int32_array);
        assert(__bufferSize_typedarray_length >= 1);
        int32_t* __arg3 = (int32_t*)__bufferSize_typedarray_data;
        ErrorCode ___ret = ::TaikoDifficultyCalculator_CalculateModsTimed(__arg0, __arg1, __arg2, __arg3);

        if (!__nativeTimedAttributesBuffer_is_null)
        {
            int32_t __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_bufferSize_ptr[0];
            if (__nativeTimedAttributesBuffer_written < 0) __nativeTimedAttributesBuffer_written = 0;
            if (__nativeTimedAttributesBuffer_written > __nativeTimedAttributesBuffer_buffer_count) __nativeTimedAttributesBuffer_written = __nativeTimedAttributesBuffer_buffer_count;

            napi_value __nativeTimedAttributesBuffer_ctor;
            status = napi_get_reference_value(env, ctor_NativeTimedTaikoDifficultyAttributes_NativeTimedTaikoDifficultyAttributes, &__nativeTimedAttributesBuffer_ctor);
            assert(status == napi_ok);

            for (int32_t i = 0; i < __nativeTimedAttributesBuffer_written; i++)
            {
                napi_value __nativeTimedAttributesBuffer_instance;
                status = napi_new_instance(env, __nativeTimedAttributesBuffer_ctor, 0, nullptr, &__nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
                NativeTimedTaikoDifficultyAttributes* __nativeTimedAttributesBuffer_native;
                status = napi_unwrap(env, __nativeTimedAttributesBuffer_instance, (void**) &__nativeTimedAttributesBuffer_native);
                assert(status == napi_ok);
                *__nativeTimedAttributesBuffer_native = __nativeTimedAttributesBuffer_buffer[(size_t)i];
                status = napi_set_element(env, args[2], (uint32_t)i, __nativeTimedAttributesBuffer_instance);
                assert(status == napi_ok);
            }
        }

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__TaikoDifficultyCalculator_CalculateModsTimed(napi_env env)
{
    napi_status status;
    napi_value __TaikoDifficultyCalculator_CalculateModsTimed;
    status = napi_create_function(env, "TaikoDifficultyCalculator_CalculateModsTimed", NAPI_AUTO_LENGTH, callback_function__TaikoDifficultyCalculator_CalculateModsTimed, 0, &__TaikoDifficultyCalculator_CalculateModsTimed);
    assert(status == napi_ok);

    return __TaikoDifficultyCalculator_CalculateModsTimed;
}

// TaikoDifficultyCalculator_Destroy
static napi_value callback_function__TaikoDifficultyCalculator_Destroy(napi_env env, napi_callback_info info)
{
    napi_status status;
    napi_value _this;
    size_t argc;
    status = napi_get_cb_info(env, info, &argc, nullptr, &_this, nullptr);
    assert(status == napi_ok);

    std::vector<napi_value> args(argc);
    std::vector<napi_valuetype> types(argc);

    if (argc < 1 || argc > 1)
    {
        status = napi_throw_type_error(env, nullptr, "Unsupported number of arguments");
        assert(status == napi_ok);

        return nullptr;
    }

    status = napi_get_cb_info(env, info, &argc, argc > 0 ? args.data() : nullptr, nullptr, nullptr);
    assert(status == napi_ok);

    for (size_t i = 0; i < argc; i++)
    {
        status = napi_typeof(env, args[i], &types[i]);
        assert(status == napi_ok);
    }

    if (NAPI_IS_OBJECT(types[0]))
        goto overload0;

    goto error;

error:
    status = napi_throw_type_error(env, nullptr, "Unsupported argument type");
    assert(status == napi_ok);

    return nullptr;

    // ErrorCode TaikoDifficultyCalculator_Destroy(ManagedObjectHandle handle)
overload0:
    {
        ManagedObjectHandle* handle_instance;
        status = napi_unwrap(env, args[0], (void**) &handle_instance);
        auto __arg0 = *handle_instance;

        ErrorCode ___ret = ::TaikoDifficultyCalculator_Destroy(__arg0);

        napi_value _____ret;
        status = napi_create_int32(env, (int32_t) ___ret, &_____ret);
        assert(status == napi_ok);

        return _____ret;
    }

    return nullptr;
}

static napi_value register_function__TaikoDifficultyCalculator_Destroy(napi_env env)
{
    napi_status status;
    napi_value __TaikoDifficultyCalculator_Destroy;
    status = napi_create_function(env, "TaikoDifficultyCalculator_Destroy", NAPI_AUTO_LENGTH, callback_function__TaikoDifficultyCalculator_Destroy, 0, &__TaikoDifficultyCalculator_Destroy);
    assert(status == napi_ok);

    return __TaikoDifficultyCalculator_Destroy;
}

void register_cabinet(napi_env env, napi_value exports)
{
    napi_value value;

    value = register_enum__ErrorCode(env, exports);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ErrorCode", value));

    value = register_class__ManagedObjectHandle(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ManagedObjectHandle", value));

    value = register_class__NativeBeatmap(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeBeatmap", value));

    value = register_class__NativeMod(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeMod", value));

    value = register_class__NativeModsCollection(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeModsCollection", value));

    value = register_class__NativeRuleset(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeRuleset", value));

    value = register_class__NativeScoreInfo(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeScoreInfo", value));

    value = register_class__NativeCatchPerformanceAttributes(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeCatchPerformanceAttributes", value));

    value = register_class__NativeCatchPerformanceCalculator(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeCatchPerformanceCalculator", value));

    value = register_class__NativeManiaPerformanceAttributes(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeManiaPerformanceAttributes", value));

    value = register_class__NativeManiaPerformanceCalculator(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeManiaPerformanceCalculator", value));

    value = register_class__Cabinet__Nullable_double(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Cabinet__Nullable_double", value));

    value = register_class__NativeOsuPerformanceAttributes(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeOsuPerformanceAttributes", value));

    value = register_class__NativeOsuPerformanceCalculator(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeOsuPerformanceCalculator", value));

    value = register_class__NativeTaikoPerformanceAttributes(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeTaikoPerformanceAttributes", value));

    value = register_class__NativeTaikoPerformanceCalculator(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeTaikoPerformanceCalculator", value));

    value = register_class__NativeCatchDifficultyAttributes(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeCatchDifficultyAttributes", value));

    value = register_class__NativeCatchDifficultyCalculator(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeCatchDifficultyCalculator", value));

    value = register_class__NativeManiaDifficultyAttributes(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeManiaDifficultyAttributes", value));

    value = register_class__NativeManiaDifficultyCalculator(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeManiaDifficultyCalculator", value));

    value = register_class__NativeOsuDifficultyAttributes(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeOsuDifficultyAttributes", value));

    value = register_class__NativeOsuDifficultyCalculator(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeOsuDifficultyCalculator", value));

    value = register_class__NativeTaikoDifficultyAttributes(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeTaikoDifficultyAttributes", value));

    value = register_class__NativeTaikoDifficultyCalculator(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeTaikoDifficultyCalculator", value));

    value = register_class__NativeTimedCatchDifficultyAttributes(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeTimedCatchDifficultyAttributes", value));

    value = register_class__NativeTimedManiaDifficultyAttributes(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeTimedManiaDifficultyAttributes", value));

    value = register_class__NativeTimedOsuDifficultyAttributes(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeTimedOsuDifficultyAttributes", value));

    value = register_class__NativeTimedTaikoDifficultyAttributes(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "NativeTimedTaikoDifficultyAttributes", value));

    typedef ::ErrorCode ErrorCode;
    typedef ::ManagedObjectHandle ManagedObjectHandle;
    typedef ::NativeBeatmap NativeBeatmap;
    typedef ::NativeMod NativeMod;
    typedef ::NativeModsCollection NativeModsCollection;
    typedef ::NativeRuleset NativeRuleset;
    typedef ::NativeScoreInfo NativeScoreInfo;
    typedef ::NativeCatchPerformanceAttributes NativeCatchPerformanceAttributes;
    typedef ::NativeCatchPerformanceCalculator NativeCatchPerformanceCalculator;
    typedef ::NativeManiaPerformanceAttributes NativeManiaPerformanceAttributes;
    typedef ::NativeManiaPerformanceCalculator NativeManiaPerformanceCalculator;
    typedef ::Cabinet__Nullable_double Cabinet__Nullable_double;
    typedef ::NativeOsuPerformanceAttributes NativeOsuPerformanceAttributes;
    typedef ::NativeOsuPerformanceCalculator NativeOsuPerformanceCalculator;
    typedef ::NativeTaikoPerformanceAttributes NativeTaikoPerformanceAttributes;
    typedef ::NativeTaikoPerformanceCalculator NativeTaikoPerformanceCalculator;
    typedef ::NativeCatchDifficultyAttributes NativeCatchDifficultyAttributes;
    typedef ::NativeCatchDifficultyCalculator NativeCatchDifficultyCalculator;
    typedef ::NativeManiaDifficultyAttributes NativeManiaDifficultyAttributes;
    typedef ::NativeManiaDifficultyCalculator NativeManiaDifficultyCalculator;
    typedef ::NativeOsuDifficultyAttributes NativeOsuDifficultyAttributes;
    typedef ::NativeOsuDifficultyCalculator NativeOsuDifficultyCalculator;
    typedef ::NativeTaikoDifficultyAttributes NativeTaikoDifficultyAttributes;
    typedef ::NativeTaikoDifficultyCalculator NativeTaikoDifficultyCalculator;
    typedef ::NativeTimedCatchDifficultyAttributes NativeTimedCatchDifficultyAttributes;
    typedef ::NativeTimedManiaDifficultyAttributes NativeTimedManiaDifficultyAttributes;
    typedef ::NativeTimedOsuDifficultyAttributes NativeTimedOsuDifficultyAttributes;
    typedef ::NativeTimedTaikoDifficultyAttributes NativeTimedTaikoDifficultyAttributes;

    value = register_function__ErrorHandler_GetLastMessage(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ErrorHandler_GetLastMessage", value));

    value = register_function__Beatmap_CreateFromFile(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Beatmap_CreateFromFile", value));

    value = register_function__Beatmap_CreateFromText(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Beatmap_CreateFromText", value));

    value = register_function__Beatmap_GetTitle(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Beatmap_GetTitle", value));

    value = register_function__Beatmap_GetArtist(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Beatmap_GetArtist", value));

    value = register_function__Beatmap_GetVersion(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Beatmap_GetVersion", value));

    value = register_function__Beatmap_Destroy(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Beatmap_Destroy", value));

    value = register_function__Mod_Create(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Mod_Create", value));

    value = register_function__Mod_SetSettingBool(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Mod_SetSettingBool", value));

    value = register_function__Mod_SetSettingInteger(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Mod_SetSettingInteger", value));

    value = register_function__Mod_SetSettingFloat(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Mod_SetSettingFloat", value));

    value = register_function__Mod_Debug(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Mod_Debug", value));

    value = register_function__Mod_Destroy(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Mod_Destroy", value));

    value = register_function__ModsCollection_Create(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ModsCollection_Create", value));

    value = register_function__ModsCollection_Add(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ModsCollection_Add", value));

    value = register_function__ModsCollection_Remove(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ModsCollection_Remove", value));

    value = register_function__ModsCollection_Debug(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ModsCollection_Debug", value));

    value = register_function__ModsCollection_Destroy(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ModsCollection_Destroy", value));

    value = register_function__Ruleset_CreateFromId(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Ruleset_CreateFromId", value));

    value = register_function__Ruleset_CreateFromShortName(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Ruleset_CreateFromShortName", value));

    value = register_function__Ruleset_GetShortName(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Ruleset_GetShortName", value));

    value = register_function__Ruleset_Destroy(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "Ruleset_Destroy", value));

    value = register_function__CatchPerformanceCalculator_Create(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "CatchPerformanceCalculator_Create", value));

    value = register_function__CatchPerformanceCalculator_Calculate(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "CatchPerformanceCalculator_Calculate", value));

    value = register_function__CatchPerformanceCalculator_Destroy(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "CatchPerformanceCalculator_Destroy", value));

    value = register_function__ManiaPerformanceCalculator_Create(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ManiaPerformanceCalculator_Create", value));

    value = register_function__ManiaPerformanceCalculator_Calculate(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ManiaPerformanceCalculator_Calculate", value));

    value = register_function__ManiaPerformanceCalculator_Destroy(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ManiaPerformanceCalculator_Destroy", value));

    value = register_function__OsuPerformanceCalculator_Create(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "OsuPerformanceCalculator_Create", value));

    value = register_function__OsuPerformanceCalculator_Calculate(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "OsuPerformanceCalculator_Calculate", value));

    value = register_function__OsuPerformanceCalculator_Destroy(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "OsuPerformanceCalculator_Destroy", value));

    value = register_function__TaikoPerformanceCalculator_Create(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "TaikoPerformanceCalculator_Create", value));

    value = register_function__TaikoPerformanceCalculator_Calculate(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "TaikoPerformanceCalculator_Calculate", value));

    value = register_function__TaikoPerformanceCalculator_Destroy(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "TaikoPerformanceCalculator_Destroy", value));

    value = register_function__CatchDifficultyCalculator_Create(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "CatchDifficultyCalculator_Create", value));

    value = register_function__CatchDifficultyCalculator_Calculate(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "CatchDifficultyCalculator_Calculate", value));

    value = register_function__CatchDifficultyCalculator_CalculateMods(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "CatchDifficultyCalculator_CalculateMods", value));

    value = register_function__CatchDifficultyCalculator_CalculateTimed(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "CatchDifficultyCalculator_CalculateTimed", value));

    value = register_function__CatchDifficultyCalculator_CalculateModsTimed(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "CatchDifficultyCalculator_CalculateModsTimed", value));

    value = register_function__CatchDifficultyCalculator_Destroy(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "CatchDifficultyCalculator_Destroy", value));

    value = register_function__ManiaDifficultyCalculator_Create(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ManiaDifficultyCalculator_Create", value));

    value = register_function__ManiaDifficultyCalculator_Calculate(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ManiaDifficultyCalculator_Calculate", value));

    value = register_function__ManiaDifficultyCalculator_CalculateMods(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ManiaDifficultyCalculator_CalculateMods", value));

    value = register_function__ManiaDifficultyCalculator_CalculateTimed(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ManiaDifficultyCalculator_CalculateTimed", value));

    value = register_function__ManiaDifficultyCalculator_CalculateModsTimed(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ManiaDifficultyCalculator_CalculateModsTimed", value));

    value = register_function__ManiaDifficultyCalculator_Destroy(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "ManiaDifficultyCalculator_Destroy", value));

    value = register_function__OsuDifficultyCalculator_Create(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "OsuDifficultyCalculator_Create", value));

    value = register_function__OsuDifficultyCalculator_Calculate(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "OsuDifficultyCalculator_Calculate", value));

    value = register_function__OsuDifficultyCalculator_CalculateMods(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "OsuDifficultyCalculator_CalculateMods", value));

    value = register_function__OsuDifficultyCalculator_CalculateTimed(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "OsuDifficultyCalculator_CalculateTimed", value));

    value = register_function__OsuDifficultyCalculator_CalculateModsTimed(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "OsuDifficultyCalculator_CalculateModsTimed", value));

    value = register_function__OsuDifficultyCalculator_Destroy(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "OsuDifficultyCalculator_Destroy", value));

    value = register_function__TaikoDifficultyCalculator_Create(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "TaikoDifficultyCalculator_Create", value));

    value = register_function__TaikoDifficultyCalculator_Calculate(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "TaikoDifficultyCalculator_Calculate", value));

    value = register_function__TaikoDifficultyCalculator_CalculateMods(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "TaikoDifficultyCalculator_CalculateMods", value));

    value = register_function__TaikoDifficultyCalculator_CalculateTimed(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "TaikoDifficultyCalculator_CalculateTimed", value));

    value = register_function__TaikoDifficultyCalculator_CalculateModsTimed(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "TaikoDifficultyCalculator_CalculateModsTimed", value));

    value = register_function__TaikoDifficultyCalculator_Destroy(env);
    NAPI_CALL_NORET(env, napi_set_named_property(env, exports, "TaikoDifficultyCalculator_Destroy", value));
}
